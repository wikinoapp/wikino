# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `vips` gem.
# Please instead update this file by running `bin/tapioca gem vips`.


# source://vips//lib/vips.rb#36
module GLib
  extend ::FFI::Library

  # source://vips//lib/vips.rb#51
  def g_free(*_arg0); end

  # source://vips//lib/vips.rb#56
  def g_log_remove_handler(*_arg0); end

  # source://vips//lib/vips.rb#54
  def g_log_set_handler(*_arg0); end

  # source://vips//lib/vips.rb#47
  def g_malloc(*_arg0); end

  class << self
    # source://vips//lib/vips.rb#51
    def g_free(*_arg0); end

    # source://vips//lib/vips.rb#56
    def g_log_remove_handler(*_arg0); end

    # source://vips//lib/vips.rb#54
    def g_log_set_handler(*_arg0); end

    # source://vips//lib/vips.rb#47
    def g_malloc(*_arg0); end

    # Returns the value of attribute logger.
    #
    # source://vips//lib/vips.rb#38
    def logger; end

    # Sets the attribute logger
    #
    # @param value the value to set the attribute logger to.
    #
    # source://vips//lib/vips.rb#38
    def logger=(_arg0); end

    # source://vips//lib/vips.rb#90
    def remove_log_handler; end

    # source://vips//lib/vips.rb#97
    def set_log_domain(domain); end
  end
end

# map glib levels to Logger::Severity
#
# source://vips//lib/vips.rb#71
GLib::GLIB_TO_SEVERITY = T.let(T.unsafe(nil), Hash)

# save the FFI::Function that attach will return ... we can use it directly
# as a param for callbacks
#
# source://vips//lib/vips.rb#51
GLib::G_FREE = T.let(T.unsafe(nil), FFI::Function)

# source://vips//lib/vips.rb#60
GLib::LOG_FLAG_FATAL = T.let(T.unsafe(nil), Integer)

# log flags
#
# source://vips//lib/vips.rb#59
GLib::LOG_FLAG_RECURSION = T.let(T.unsafe(nil), Integer)

# module-level, so it's not GCd away
#
# source://vips//lib/vips.rb#86
GLib::LOG_HANDLER = T.let(T.unsafe(nil), Proc)

# always fatal
#
# source://vips//lib/vips.rb#64
GLib::LOG_LEVEL_CRITICAL = T.let(T.unsafe(nil), Integer)

# source://vips//lib/vips.rb#68
GLib::LOG_LEVEL_DEBUG = T.let(T.unsafe(nil), Integer)

# GLib log levels
#
# source://vips//lib/vips.rb#63
GLib::LOG_LEVEL_ERROR = T.let(T.unsafe(nil), Integer)

# source://vips//lib/vips.rb#67
GLib::LOG_LEVEL_INFO = T.let(T.unsafe(nil), Integer)

# source://vips//lib/vips.rb#66
GLib::LOG_LEVEL_MESSAGE = T.let(T.unsafe(nil), Integer)

# source://vips//lib/vips.rb#65
GLib::LOG_LEVEL_WARNING = T.let(T.unsafe(nil), Integer)

# source://vips//lib/vips.rb#134
module GObject
  extend ::FFI::Library

  # source://vips//lib/vips/gvalue.rb#285
  def g_object_get_property(*_arg0); end

  # source://vips//lib/vips/gobject.rb#126
  def g_object_ref(*_arg0); end

  # source://vips//lib/vips/gvalue.rb#283
  def g_object_set_property(*_arg0); end

  # source://vips//lib/vips/gobject.rb#127
  def g_object_unref(*_arg0); end

  # source://vips//lib/vips/gobject.rb#124
  def g_param_spec_get_blurb(*_arg0); end

  # source://vips//lib/vips/gobject.rb#131
  def g_signal_connect_data(*_arg0); end

  # source://vips//lib/vips.rb#148
  def g_type_from_name(*_arg0); end

  # source://vips//lib/vips.rb#149
  def g_type_fundamental(*_arg0); end

  # source://vips//lib/vips.rb#146
  def g_type_init(*_arg0); end

  # source://vips//lib/vips.rb#147
  def g_type_name(*_arg0); end

  # source://vips//lib/vips/gvalue.rb#273
  def g_value_get_boolean(*_arg0); end

  # source://vips//lib/vips/gvalue.rb#276
  def g_value_get_double(*_arg0); end

  # source://vips//lib/vips/gvalue.rb#277
  def g_value_get_enum(*_arg0); end

  # source://vips//lib/vips/gvalue.rb#278
  def g_value_get_flags(*_arg0); end

  # source://vips//lib/vips/gvalue.rb#274
  def g_value_get_int(*_arg0); end

  # source://vips//lib/vips/gvalue.rb#280
  def g_value_get_object(*_arg0); end

  # source://vips//lib/vips/gvalue.rb#279
  def g_value_get_string(*_arg0); end

  # source://vips//lib/vips/gvalue.rb#275
  def g_value_get_uint64(*_arg0); end

  # source://vips//lib/vips/gvalue.rb#258
  def g_value_init(*_arg0); end

  # source://vips//lib/vips/gvalue.rb#264
  def g_value_set_boolean(*_arg0); end

  # source://vips//lib/vips/gvalue.rb#267
  def g_value_set_double(*_arg0); end

  # source://vips//lib/vips/gvalue.rb#268
  def g_value_set_enum(*_arg0); end

  # source://vips//lib/vips/gvalue.rb#269
  def g_value_set_flags(*_arg0); end

  # source://vips//lib/vips/gvalue.rb#265
  def g_value_set_int(*_arg0); end

  # source://vips//lib/vips/gvalue.rb#271
  def g_value_set_object(*_arg0); end

  # source://vips//lib/vips/gvalue.rb#270
  def g_value_set_string(*_arg0); end

  # source://vips//lib/vips/gvalue.rb#266
  def g_value_set_uint64(*_arg0); end

  # source://vips//lib/vips/gvalue.rb#262
  def g_value_unset(*_arg0); end

  class << self
    # source://vips//lib/vips/gvalue.rb#285
    def g_object_get_property(*_arg0); end

    # source://vips//lib/vips/gobject.rb#126
    def g_object_ref(*_arg0); end

    # source://vips//lib/vips/gvalue.rb#283
    def g_object_set_property(*_arg0); end

    # source://vips//lib/vips/gobject.rb#127
    def g_object_unref(*_arg0); end

    # source://vips//lib/vips/gobject.rb#124
    def g_param_spec_get_blurb(*_arg0); end

    # source://vips//lib/vips/gobject.rb#131
    def g_signal_connect_data(*_arg0); end

    # source://vips//lib/vips.rb#148
    def g_type_from_name(*_arg0); end

    # source://vips//lib/vips.rb#149
    def g_type_fundamental(*_arg0); end

    # source://vips//lib/vips.rb#146
    def g_type_init(*_arg0); end

    # source://vips//lib/vips.rb#147
    def g_type_name(*_arg0); end

    # source://vips//lib/vips/gvalue.rb#273
    def g_value_get_boolean(*_arg0); end

    # source://vips//lib/vips/gvalue.rb#276
    def g_value_get_double(*_arg0); end

    # source://vips//lib/vips/gvalue.rb#277
    def g_value_get_enum(*_arg0); end

    # source://vips//lib/vips/gvalue.rb#278
    def g_value_get_flags(*_arg0); end

    # source://vips//lib/vips/gvalue.rb#274
    def g_value_get_int(*_arg0); end

    # source://vips//lib/vips/gvalue.rb#280
    def g_value_get_object(*_arg0); end

    # source://vips//lib/vips/gvalue.rb#279
    def g_value_get_string(*_arg0); end

    # source://vips//lib/vips/gvalue.rb#275
    def g_value_get_uint64(*_arg0); end

    # source://vips//lib/vips/gvalue.rb#258
    def g_value_init(*_arg0); end

    # source://vips//lib/vips/gvalue.rb#264
    def g_value_set_boolean(*_arg0); end

    # source://vips//lib/vips/gvalue.rb#267
    def g_value_set_double(*_arg0); end

    # source://vips//lib/vips/gvalue.rb#268
    def g_value_set_enum(*_arg0); end

    # source://vips//lib/vips/gvalue.rb#269
    def g_value_set_flags(*_arg0); end

    # source://vips//lib/vips/gvalue.rb#265
    def g_value_set_int(*_arg0); end

    # source://vips//lib/vips/gvalue.rb#271
    def g_value_set_object(*_arg0); end

    # source://vips//lib/vips/gvalue.rb#270
    def g_value_set_string(*_arg0); end

    # source://vips//lib/vips/gvalue.rb#266
    def g_value_set_uint64(*_arg0); end

    # source://vips//lib/vips/gvalue.rb#262
    def g_value_unset(*_arg0); end
  end
end

# look up some common gtypes
#
# source://vips//lib/vips.rb#155
GObject::GBOOL_TYPE = T.let(T.unsafe(nil), Integer)

# source://vips//lib/vips.rb#158
GObject::GDOUBLE_TYPE = T.let(T.unsafe(nil), Integer)

# source://vips//lib/vips.rb#159
GObject::GENUM_TYPE = T.let(T.unsafe(nil), Integer)

# source://vips//lib/vips.rb#160
GObject::GFLAGS_TYPE = T.let(T.unsafe(nil), Integer)

# source://vips//lib/vips.rb#156
GObject::GINT_TYPE = T.let(T.unsafe(nil), Integer)

# source://vips//lib/vips.rb#162
GObject::GOBJECT_TYPE = T.let(T.unsafe(nil), Integer)

# we have a number of things we need to inherit in different ways:
#
# - we want to be able to subclass GObject in Ruby in a simple way
# - the layouts of the nested structs need to inherit
# - we need to be able to cast between structs which share a base struct
#   without creating new wrappers or messing up refcounting
# - we need automatic gobject refcounting
#
# the solution is to split the class into four areas which we treat
# differently:
#
# - we have a "wrapper" Ruby class to allow easy subclassing ... this has a
#   @struct member which holds the actual pointer
# - we use "forwardable" to forward the various ffi methods on to the
#   @struct member ... we arrange things so that subclasses do not need to
#   do the forwarding themselves
# - we have two versions of the struct: a plain one which we can use for
#   casting that will not change the refcounts
# - and a managed one with an unref which we just use for .new
# - we separate the struct layout into a separate module to avoid repeating
#   ourselves
#
# source://vips//lib/vips/gobject.rb#33
class GObject::GObject
  extend ::Forwardable
  extend ::SingleForwardable

  # don't allow ptr == nil, we never want to allocate a GObject struct
  # ourselves, we just want to wrap GLib-allocated GObjects
  #
  # here we use ManagedStruct, not Struct, since this is the ref that will
  # need the unref
  #
  # @return [GObject] a new instance of GObject
  #
  # source://vips//lib/vips/gobject.rb#75
  def initialize(ptr); end

  # source://vips//lib/vips/gobject.rb#37
  def [](*args, **_arg1, &block); end

  # access to the managed struct for this class
  #
  # source://vips//lib/vips/gobject.rb#100
  def ffi_managed_struct; end

  # access to the casting struct for this class
  #
  # source://vips//lib/vips/gobject.rb#85
  def ffi_struct; end

  # get the pointer we were built from ... #to_ptr gets the pointer after we
  # have wrapped it up with an auto unref
  #
  # source://vips//lib/vips/gobject.rb#91
  def ptr; end

  # Returns the value of attribute references.
  #
  # source://vips//lib/vips/gobject.rb#40
  def references; end

  # source://vips//lib/vips/gobject.rb#37
  def to_ptr(*args, **_arg1, &block); end

  class << self
    # source://vips//lib/vips/gobject.rb#105
    def ffi_managed_struct; end

    # source://vips//lib/vips/gobject.rb#94
    def ffi_struct; end

    # source://vips//lib/vips/gobject.rb#38
    def ptr(*args, **_arg1, &block); end
  end
end

# the layout of the GObject struct
#
# source://vips//lib/vips/gobject.rb#43
module GObject::GObject::GObjectLayout
  class << self
    # @private
    #
    # source://vips//lib/vips/gobject.rb#44
    def included(base); end
  end
end

# the struct with unref ... manage object lifetime with this
#
# source://vips//lib/vips/gobject.rb#54
class GObject::GObject::ManagedStruct < ::FFI::ManagedStruct
  include ::GObject::GObject::GObjectLayout

  class << self
    # source://vips//lib/vips/gobject.rb#57
    def release(ptr); end
  end
end

# the plain struct ... cast with this
#
# source://vips//lib/vips/gobject.rb#66
class GObject::GObject::Struct < ::FFI::Struct
  include ::GObject::GObject::GObjectLayout
end

# source://vips//lib/vips/gobject.rb#111
class GObject::GParamSpec < ::FFI::Struct; end

# source://vips//lib/vips/gobject.rb#120
class GObject::GParamSpecPtr < ::FFI::Struct; end

# source://vips//lib/vips.rb#161
GObject::GSTR_TYPE = T.let(T.unsafe(nil), Integer)

# source://vips//lib/vips.rb#157
GObject::GUINT64_TYPE = T.let(T.unsafe(nil), Integer)

# Represent a GValue. Example use:
#
# ```ruby
# gvalue = GValue::alloc
# gvalue.init GObject::GDOUBLE_TYPE
# gvalue.set 3.1415
# value = gvalue.get
# # optional -- drop any ref the gvalue had
# gvalue.unset
# ```
#
# Lifetime is managed automatically. It doesn't know about all GType values,
# but it does know the ones that libvips uses.
#
# source://vips//lib/vips/gvalue.rb#23
class GObject::GValue < ::FFI::ManagedStruct
  # Get the value of a GValue. The value is converted to a Ruby type in
  # the obvious way.
  #
  # @return [Any] the value held by the GValue
  #
  # source://vips//lib/vips/gvalue.rb#171
  def get; end

  # Set the type of thing a gvalue can hold.
  #
  # @param gtype [GType] the type of thing this GValue can hold.
  #
  # source://vips//lib/vips/gvalue.rb#79
  def init(gtype); end

  # Set the value of a GValue. The value is converted to the type of the
  # GValue, if possible.
  #
  # @param value [Any] The value to set
  #
  # source://vips//lib/vips/gvalue.rb#87
  def set(value); end

  # Clear the thing held by a GValue.
  #
  # This happens automatically when a GValue is GCed, but this method can be
  # handy if you need to drop a reference explicitly for some reason.
  #
  # source://vips//lib/vips/gvalue.rb#253
  def unset; end

  class << self
    # Allocate memory for a GValue and return a class wrapper. Memory will
    # be freed automatically when it goes out of scope. The GValue is inited
    # to 0, use {GValue.init} to set a type.
    #
    # @return [GValue] a new gvalue set to 0
    #
    # source://vips//lib/vips/gvalue.rb#63
    def alloc; end

    # convert an enum value (str/symb/int) into an int ready for libvips
    #
    # source://vips//lib/vips/gvalue.rb#28
    def from_nick(gtype, value); end

    # source://vips//lib/vips/gvalue.rb#53
    def release(ptr); end

    # convert an int enum back into a symbol
    #
    # source://vips//lib/vips/gvalue.rb#44
    def to_nick(gtype, enum_value); end
  end
end

class Object < ::BasicObject
  include ::Kernel
  include ::PP::ObjectMixin

  private

  # source://vips//lib/vips.rb#26
  def library_name(name, abi_number); end
end

# This module provides a binding for the [libvips image processing
# library](https://libvips.github.io/libvips/).
#
# # Example
#
# ```ruby
# require 'vips'
#
# if ARGV.length < 2
#     raise "usage: #{$PROGRAM_NAME}: input-file output-file"
# end
#
# im = Vips::Image.new_from_file ARGV[0], access: :sequential
#
# im *= [1, 2, 1]
#
# mask = Vips::Image.new_from_array [
#         [-1, -1, -1],
#         [-1, 16, -1],
#         [-1, -1, -1]
#        ], 8
# im = im.conv mask, precision: :integer
#
# im.write_to_file ARGV[1]
# ```
#
# This example loads a file, boosts the green channel (I'm not sure why),
# sharpens the image, and saves it back to disc again.
#
# Reading this example line by line, we have:
#
# ```ruby
# im = Vips::Image.new_from_file ARGV[0], access: :sequential
# ```
#
# {Image.new_from_file} can load any image file supported by vips. In this
# example, we will be accessing pixels top-to-bottom as we sweep through the
# image reading and writing, so `:sequential` access mode is best for us. The
# default mode is `:random`: this allows for full random access to image pixels,
# but is slower and needs more memory. See {Access}
# for full details
# on the various modes available.
#
# You can also load formatted images from memory buffers, create images that
# wrap C-style memory arrays, or make images from constants. Use {Source}
# and {Image.new_from_source} to load images from any data source, for
# example URIs.
#
# The next line:
#
# ```ruby
# im *= [1, 2, 1]
# ```
#
# Multiplying the image by an array constant uses one array element for each
# image band. This line assumes that the input image has three bands and will
# double the middle band. For RGB images, that's doubling green.
#
# Next we have:
#
# ```ruby
# mask = Vips::Image.new_from_array [
#         [-1, -1, -1],
#         [-1, 16, -1],
#         [-1, -1, -1]
#        ], 8
# im = im.conv mask, precision: :integer
# ```
#
# {Image.new_from_array} creates an image from an array constant. The 8 at
# the end sets the scale: the amount to divide the image by after
# integer convolution.
#
# See the libvips API docs for `vips_conv()` (the operation
# invoked by {Image#conv}) for details on the convolution operator. By default,
# it computes with a float mask, but `:integer` is fine for this case, and is
# much faster.
#
# Finally:
#
# ```ruby
# im.write_to_file ARGV[1]
# ```
#
# {Image#write_to_file} writes an image back to the filesystem. It can
# write any format supported by vips: the file type is set from the filename
# suffix. You can also write formatted images to memory buffers, or dump
# image data to a raw memory array.
#
# Use {Target} and {Image#write_to_target} to write formatted images to
# any data sink, for example URIs.
#
# # How it works
#
# The binding uses [ruby-ffi](https://github.com/ffi/ffi) to open the libvips
# shared library. When you call a method on the image class, it uses libvips
# introspection system (based on GObject) to search the
# library for an operation of that name, transforms the arguments to a form
# libvips can digest, and runs the operation.
#
# This means ruby-vips always presents the API implemented by the libvips shared
# library. It should update itself as new features are added.
#
# # Automatic wrapping
#
# `ruby-vips` adds a {Image.method_missing} handler to {Image} and uses
# it to look up vips operations. For example, the libvips operation `add`, which
# appears in C as `vips_add()`, appears in Ruby as {Image#add}.
#
# The operation's list of required arguments is searched and the first input
# image is set to the value of `self`. Operations which do not take an input
# image, such as {Image.black}, appear as class methods. The remainder of
# the arguments you supply in the function call are used to set the other
# required input arguments. Any trailing keyword arguments are used to set
# options on the operation.
#
# The result is the required output
# argument if there is only one result, or an array of values if the operation
# produces several results. If the operation has optional output objects, they
# are returned as a final hash.
#
# For example, {Image#min}, the vips operation that searches an image for
# the minimum value, has a large number of optional arguments. You can use it to
# find the minimum value like this:
#
# ```ruby
# min_value = image.min
# ```
#
# You can ask it to return the position of the minimum with `:x` and `:y`.
#
# ```ruby
# min_value, opts = min x: true, y: true
# x_pos = opts['x']
# y_pos = opts['y']
# ```
#
# Now `x_pos` and `y_pos` will have the coordinates of the minimum value.
# There's actually a convenience method for this, {Image#minpos}.
#
# You can also ask for the top *n* minimum, for example:
#
# ```ruby
# min_value, opts = min size: 10, x_array: true, y_array: true
# x_pos = opts['x_array']
# y_pos = opts['y_array']
# ```
#
# Now `x_pos` and `y_pos` will be 10-element arrays.
#
# Because operations are member functions and return the result image, you can
# chain them. For example, you can write:
#
# ```ruby
# result_image = image.real.cos
# ```
#
# to calculate the cosine of the real part of a complex image.
# There are also a full set
# of arithmetic operator overloads, see below.
#
# libvips types are also automatically wrapped. The override looks at the type
# of argument required by the operation and converts the value you supply,
# when it can. For example, {Image#linear} takes a `VipsArrayDouble` as
# an argument
# for the set of constants to use for multiplication. You can supply this
# value as an integer, a float, or some kind of compound object and it
# will be converted for you. You can write:
#
# ```ruby
# result_image = image.linear 1, 3
# result_image = image.linear 12.4, 13.9
# result_image = image.linear [1, 2, 3], [4, 5, 6]
# result_image = image.linear 1, [4, 5, 6]
# ```
#
# And so on. A set of overloads are defined for {Image#linear}, see below.
#
# It does a couple of more ambitious conversions. It will automatically convert
# to and from the various vips types, like `VipsBlob` and `VipsArrayImage`. For
# example, you can read the ICC profile out of an image like this:
#
# ```ruby
# profile = im.get_value "icc-profile-data"
# ```
#
# and profile will be a byte array.
#
# If an operation takes several input images, you can use a constant for all but
# one of them and the wrapper will expand the constant to an image for you. For
# example, {Image#ifthenelse} uses a condition image to pick pixels
# between a then and an else image:
#
# ```ruby
# result_image = condition_image.ifthenelse then_image, else_image
# ```
#
# You can use a constant instead of either the then or the else parts and it
# will be expanded to an image for you. If you use a constant for both then and
# else, it will be expanded to match the condition image. For example:
#
# ```ruby
# result_image = condition_image.ifthenelse [0, 255, 0], [255, 0, 0]
# ```
#
# Will make an image where true pixels are green and false pixels are red.
#
# This is useful for {Image#bandjoin}, the thing to join two or more
# images up bandwise. You can write:
#
# ```ruby
# rgba = rgb.bandjoin 255
# ```
#
# to append a constant 255 band to an image, perhaps to add an alpha channel. Of
# course you can also write:
#
# ```ruby
# result_image = image1.bandjoin image2
# result_image = image1.bandjoin [image2, image3]
# result_image = Vips::Image.bandjoin [image1, image2, image3]
# result_image = image1.bandjoin [image2, 255]
# ```
#
# and so on.
#
# # Logging
#
# Libvips uses g_log() to log warning, debug, info and (some) error messages.
#
# https://developer.gnome.org/glib/stable/glib-Message-Logging.html
#
# You can disable warnings by defining the `VIPS_WARNING` environment variable.
# You can enable info output by defining `VIPS_INFO`.
#
# # Exceptions
#
# The wrapper spots errors from vips operations and raises the {Vips::Error}
# exception. You can catch it in the usual way.
#
# # Automatic YARD documentation
#
# The bulk of these API docs are generated automatically by {Yard#generate}.
# It examines libvips and writes a summary of each operation and the arguments
# and options that that operation expects.
#
# Use the [C API # docs](https://libvips.github.io/libvips/API/current)
# for more detail.
#
# # Enums
#
# The libvips enums, such as `VipsBandFormat` appear in ruby-vips as Symbols
# like `:uchar`. They are documented as a set of classes for convenience, see
# {Vips::BandFormat}, for example.
#
# # Draw operations
#
# There are two ways of calling the libvips draw operations, like
# {Image#draw_circle} and {Image#draw_line}.
#
# First, you can use them like functions. For example:
#
# ```ruby
# y = x.draw_line 255, 0, 0, x.width, x.height
# ```
#
# This will make a new image, `y`, which is a copy of `x` but with a line
# drawn across it. `x` is unchanged.
#
# This is simple, but will be slow if you want to draw many lines, since
# ruby-vips will make a copy of the whole image each time.
#
# You can use {Image#mutate} to make a {MutableImage}. This is an image which
# is unshared and is only available inside the {Image#mutate} block. Within
# this block, you can use `!` versions of the draw operations to modify images
# and avoid the copy. For example:
#
# ```ruby
# image = image.mutate do |mutable|
#   (0 ... 1).step(0.01) do |i|
#     mutable.draw_line! 255, mutable.width * i, 0, 0, mutable.height * (1 - i)
#   end
# end
# ```
#
# Now each {Image#draw_line} will directly modify the mutable image, saving
# the copy. This is much faster and needs much less memory.
#
# # Metadata read
#
# Use {Image#get_fields} to get a list of the metadata fields that an image
# supports. ICC profiles, for example, are in a field called
# `icc-profile-data`. Use `vipsheader -a something.jpg` at the command-line
# to see all the fields on an image.
#
# Use {Image#get_typeof} to get the type of a field. Types are integers, with
# 0 meaning "no such field". Constants like {GObject::GINT_TYPE} are useful for
# testing field types.
#
# You can read image metadata using {Image#get}. The field value is converted
# to a Ruby value in the obvious way.
#
# # Metadata write
#
# You can also set and remove image metadata fields. Images are immutable, so
# you must make any changes inside a {Image#mutate} block. For example:
#
# ```ruby
# image = image.mutate do |mutable|
#   image.get_fields.each do |field|
#     mutable.remove! field unless field == "icc-profile-data"
#   end
# end
# ```
#
# To remove all metadata except the icc profile.
#
# You can use {MutableImage#set!} to change the value of an existing field,
# and {MutableImage#set_type!} to create a new field with a specified type.
#
# # Progress
#
# You can attach signal handlers to images to watch computation progress. For
# example:
#
# ```ruby
# image = Vips::Image.black 1, 100000
# image.set_progress true
#
# def progress_to_s(name, progress)
#   puts "#{name}:"
#   puts "    run = #{progress[:run]}"
#   puts "    eta = #{progress[:eta]}"
#   puts "    tpels = #{progress[:tpels]}"
#   puts "    npels = #{progress[:npels]}"
#   puts "    percent = #{progress[:percent]}"
# end
#
# image.signal_connect :preeval do |progress|
#   progress_to_s("preeval", progress)
# end
#
# image.signal_connect :eval do |progress|
#   progress_to_s("eval", progress)
#   image.set_kill(true) if progress[:percent] > 50
# end
#
# image.signal_connect :posteval do |progress|
#   progress_to_s("posteval", progress)
# end
#
# image.avg
# ```
#
# The `:eval` signal will fire for every tile that is processed. You can stop
# progress with {Image#set_kill} and processing will end with an exception.
#
# User streams
#
# You can make your own input and output stream objects with {SourceCustom} and
# {TargetCustom}. For example:
#
# ```ruby
# file = File.open "some/file", "rb"
# source = Vips::SourceCustom.new
# source.on_read { |length| file.read length }
# image = Vips::Image.new_from_source source, "", access: "sequential"
# ```
#
# # Overloads
#
# The wrapper defines the usual set of arithmetic, boolean and relational
# overloads on image. You can mix images, constants and lists of constants
# (almost) freely. For example, you can write:
#
# ```ruby
# result_image = ((image * [1, 2, 3]).abs < 128) | 4
# ```
#
# # Expansions
#
# Some vips operators take an enum to select an action, for example
# {Image#math} can be used to calculate sine of every pixel like this:
#
# ```ruby
# result_image = image.math :sin
# ```
#
# This is annoying, so the wrapper expands all these enums into separate members
# named after the enum. So you can write:
#
# ```ruby
# result_image = image.sin
# ```
#
# # Convenience functions
#
# The wrapper defines a few extra useful utility functions:
# {Image#get_value}, {Image#set_value}, {Image#bandsplit},
# {Image#maxpos}, {Image#minpos},
# {Image#median}.
#
# source://vips//lib/vips.rb#570
module Vips
  extend ::FFI::Library

  # source://vips//lib/vips/image.rb#62
  def nickname_find(*_arg0); end

  # source://vips//lib/vips/object.rb#163
  def type_find(*_arg0); end

  # source://vips//lib/vips.rb#771
  def version(*_arg0); end

  # source://vips//lib/vips.rb#772
  def version_string(*_arg0); end

  # source://vips//lib/vips/image.rb#50
  def vips_addalpha(*args); end

  # source://vips//lib/vips/operation.rb#29
  def vips_argument_map(*_arg0); end

  # source://vips//lib/vips/object.rb#17
  def vips_band_format_get_type(*_arg0); end

  # source://vips//lib/vips/image.rb#59
  def vips_band_format_iscomplex(*_arg0); end

  # source://vips//lib/vips/image.rb#60
  def vips_band_format_isfloat(*_arg0); end

  # source://vips//lib/vips/object.rb#36
  def vips_blend_mode_get_type(*_arg0); end

  # source://vips//lib/vips.rb#659
  def vips_cache_drop_all(*_arg0); end

  # source://vips//lib/vips.rb#652
  def vips_cache_get_max(*_arg0); end

  # source://vips//lib/vips.rb#654
  def vips_cache_get_max_files(*_arg0); end

  # source://vips//lib/vips.rb#653
  def vips_cache_get_max_mem(*_arg0); end

  # source://vips//lib/vips/operation.rb#20
  def vips_cache_operation_build(*_arg0); end

  # source://vips//lib/vips.rb#658
  def vips_cache_print(*_arg0); end

  # source://vips//lib/vips.rb#655
  def vips_cache_set_max(*_arg0); end

  # source://vips//lib/vips.rb#657
  def vips_cache_set_max_files(*_arg0); end

  # source://vips//lib/vips.rb#656
  def vips_cache_set_max_mem(*_arg0); end

  # source://vips//lib/vips/object.rb#19
  def vips_coding_get_type(*_arg0); end

  # source://vips//lib/vips.rb#630
  def vips_concurrency_get(*_arg0); end

  # source://vips//lib/vips.rb#629
  def vips_concurrency_set(*_arg0); end

  # source://vips//lib/vips/connection.rb#11
  def vips_connection_filename(*_arg0); end

  # source://vips//lib/vips/connection.rb#12
  def vips_connection_nick(*_arg0); end

  # source://vips//lib/vips/object.rb#129
  def vips_enum_from_nick(*_arg0); end

  # source://vips//lib/vips/object.rb#130
  def vips_enum_nick(*_arg0); end

  # source://vips//lib/vips.rb#585
  def vips_error_buffer(*_arg0); end

  # source://vips//lib/vips.rb#586
  def vips_error_clear(*_arg0); end

  # source://vips//lib/vips.rb#587
  def vips_error_freeze(*_arg0); end

  # source://vips//lib/vips.rb#588
  def vips_error_thaw(*_arg0); end

  # source://vips//lib/vips/image.rb#20
  def vips_filename_get_filename(*_arg0); end

  # source://vips//lib/vips/image.rb#21
  def vips_filename_get_options(*_arg0); end

  # source://vips//lib/vips/image.rb#23
  def vips_foreign_find_load(*_arg0); end

  # source://vips//lib/vips/image.rb#25
  def vips_foreign_find_load_buffer(*_arg0); end

  # source://vips//lib/vips/image.rb#29
  def vips_foreign_find_load_source(*_arg0); end

  # source://vips//lib/vips/image.rb#24
  def vips_foreign_find_save(*_arg0); end

  # source://vips//lib/vips/image.rb#26
  def vips_foreign_find_save_buffer(*_arg0); end

  # source://vips//lib/vips/image.rb#30
  def vips_foreign_find_save_target(*_arg0); end

  # source://vips//lib/vips.rb#637
  def vips_foreign_get_suffixes(*_arg0); end

  # source://vips//lib/vips/image.rb#15
  def vips_image_copy_memory(*_arg0); end

  # source://vips//lib/vips/image.rb#37
  def vips_image_get(*_arg0); end

  # source://vips//lib/vips/image.rb#42
  def vips_image_get_bands(*_arg0); end

  # source://vips//lib/vips/image.rb#45
  def vips_image_get_fields(*_arg0); end

  # source://vips//lib/vips/image.rb#41
  def vips_image_get_height(*_arg0); end

  # source://vips//lib/vips/image.rb#36
  def vips_image_get_typeof(*_arg0); end

  # source://vips//lib/vips/image.rb#40
  def vips_image_get_width(*_arg0); end

  # source://vips//lib/vips/image.rb#46
  def vips_image_hasalpha(*_arg0); end

  # source://vips//lib/vips/image.rb#64
  def vips_image_invalidate_all(*_arg0); end

  # source://vips//lib/vips/image.rb#66
  def vips_image_new_from_memory(*_arg0); end

  # source://vips//lib/vips/image.rb#67
  def vips_image_new_from_memory_copy(*_arg0); end

  # source://vips//lib/vips/image.rb#12
  def vips_image_new_matrix_from_array(*_arg0); end

  # source://vips//lib/vips/image.rb#57
  def vips_image_remove(*_arg0); end

  # source://vips//lib/vips/image.rb#55
  def vips_image_set(*_arg0); end

  # source://vips//lib/vips/image.rb#18
  def vips_image_set_kill(*_arg0); end

  # source://vips//lib/vips/image.rb#17
  def vips_image_set_progress(*_arg0); end

  # source://vips//lib/vips/image.rb#33
  def vips_image_write_to_memory(*_arg0); end

  # source://vips//lib/vips.rb#617
  def vips_init(*_arg0); end

  # source://vips//lib/vips/interpolate.rb#2
  def vips_interpolate_new(*_arg0); end

  # source://vips//lib/vips/object.rb#18
  def vips_interpretation_get_type(*_arg0); end

  # source://vips//lib/vips.rb#626
  def vips_leak_set(*_arg0); end

  # source://vips//lib/vips/object.rb#328
  def vips_object_get_argument(*_arg0); end

  # source://vips//lib/vips/object.rb#339
  def vips_object_get_description(*_arg0); end

  # source://vips//lib/vips/object.rb#13
  def vips_object_print_all(*_arg0); end

  # source://vips//lib/vips/object.rb#334
  def vips_object_set_from_string(*_arg0); end

  # source://vips//lib/vips/operation.rb#22
  def vips_object_unref_outputs(*_arg0); end

  # source://vips//lib/vips/operation.rb#43
  def vips_operation_get_flags(*_arg0); end

  # source://vips//lib/vips/operation.rb#13
  def vips_operation_new(*_arg0); end

  # source://vips//lib/vips/region.rb#13
  def vips_region_fetch(*_arg0); end

  # source://vips//lib/vips/region.rb#15
  def vips_region_height(*_arg0); end

  # source://vips//lib/vips/region.rb#10
  def vips_region_new(*_arg0); end

  # source://vips//lib/vips/region.rb#14
  def vips_region_width(*_arg0); end

  # source://vips//lib/vips/sourcecustom.rb#11
  def vips_source_custom_new(*_arg0); end

  # source://vips//lib/vips/source.rb#11
  def vips_source_new_from_descriptor(*_arg0); end

  # source://vips//lib/vips/source.rb#12
  def vips_source_new_from_file(*_arg0); end

  # source://vips//lib/vips/source.rb#13
  def vips_source_new_from_memory(*_arg0); end

  # source://vips//lib/vips/targetcustom.rb#11
  def vips_target_custom_new(*_arg0); end

  # source://vips//lib/vips/target.rb#11
  def vips_target_new_to_descriptor(*_arg0); end

  # source://vips//lib/vips/target.rb#12
  def vips_target_new_to_file(*_arg0); end

  # source://vips//lib/vips/target.rb#13
  def vips_target_new_to_memory(*_arg0); end

  # source://vips//lib/vips.rb#650
  def vips_tracked_get_allocs(*_arg0); end

  # source://vips//lib/vips.rb#651
  def vips_tracked_get_files(*_arg0); end

  # source://vips//lib/vips.rb#648
  def vips_tracked_get_mem(*_arg0); end

  # source://vips//lib/vips.rb#649
  def vips_tracked_get_mem_highwater(*_arg0); end

  # source://vips//lib/vips/object.rb#337
  def vips_type_map(*_arg0); end

  # source://vips//lib/vips/object.rb#154
  def vips_value_get_array_double(*_arg0); end

  # source://vips//lib/vips/object.rb#158
  def vips_value_get_array_image(*_arg0); end

  # source://vips//lib/vips/object.rb#156
  def vips_value_get_array_int(*_arg0); end

  # source://vips//lib/vips/object.rb#160
  def vips_value_get_blob(*_arg0); end

  # source://vips//lib/vips/object.rb#152
  def vips_value_get_ref_string(*_arg0); end

  # source://vips//lib/vips/object.rb#134
  def vips_value_set_array_double(*_arg0); end

  # source://vips//lib/vips/object.rb#138
  def vips_value_set_array_image(*_arg0); end

  # source://vips//lib/vips/object.rb#136
  def vips_value_set_array_int(*_arg0); end

  # source://vips//lib/vips/object.rb#141
  def vips_value_set_blob(*_arg0); end

  # source://vips//lib/vips/object.rb#132
  def vips_value_set_ref_string(*_arg0); end

  # source://vips//lib/vips.rb#628
  def vips_vector_isenabled(*_arg0); end

  # source://vips//lib/vips.rb#627
  def vips_vector_set_enabled(*_arg0); end

  class << self
    # True if this is at least libvips x.y
    #
    # @return [Boolean]
    #
    # source://vips//lib/vips.rb#775
    def at_least_libvips?(x, y); end

    # Drop the libvips operation cache. Handy for leak tracking.
    #
    # source://vips//lib/vips.rb#724
    def cache_drop_all; end

    # Get the maximum number of operations that libvips should cache.
    #
    # source://vips//lib/vips.rb#682
    def cache_max; end

    # Get the maximum number of files libvips keeps open in the operation cache.
    #
    # source://vips//lib/vips.rb#692
    def cache_max_files; end

    # Get the maximum amount of memory that libvips uses for the operation cache.
    #
    # source://vips//lib/vips.rb#687
    def cache_max_mem; end

    # Print the libvips operation cache to stdout. Handy for debugging.
    #
    # source://vips//lib/vips.rb#719
    def cache_print; end

    # Set the maximum number of operations that libvips should cache. Set 0 to
    # disable the operation cache. The default is 1000.
    #
    # source://vips//lib/vips.rb#698
    def cache_set_max(size); end

    # Set the maximum number of files libvips should keep open in the
    # operation cache. Set 0 to disable the operation cache. The default is
    # 100.
    #
    # source://vips//lib/vips.rb#713
    def cache_set_max_files(size); end

    # Set the maximum amount of memory that libvips should use for the operation
    # cache. Set 0 to disable the operation cache. The default is 100mb.
    #
    # source://vips//lib/vips.rb#705
    def cache_set_max_mem(size); end

    # Get the size of libvips worker pools. Defaults to the VIPS_CONCURRENCY env
    # var or the number of hardware threads on your computer.
    #
    # source://vips//lib/vips.rb#730
    def concurrency; end

    # Get the default size of libvips worker pools.
    #
    # source://vips//lib/vips.rb#735
    def concurrency_default; end

    # Set the size of each libvips worker pool. Max 1024 threads. Set to 1 to
    # disable threading. Set to 0 or nil to reset to default.
    #
    # source://vips//lib/vips.rb#741
    def concurrency_set(n); end

    # Get a list of all supported file suffixes.
    #
    # @return [[String]] array of supported suffixes
    #
    # source://vips//lib/vips.rb#785
    def get_suffixes; end

    # Turn libvips leak testing on and off. Handy for debugging ruby-vips, not
    # very useful for user code.
    #
    # source://vips//lib/vips.rb#644
    def leak_set(leak); end

    # source://vips//lib/vips/image.rb#62
    def nickname_find(*_arg0); end

    # turn a raw pointer that must be freed into a self-freeing Ruby string
    #
    # source://vips//lib/vips/image.rb#70
    def p2str(pointer); end

    # Deprecated compatibility function.
    #
    # Don't use this, instead change GLib::logger.level.
    #
    # source://vips//lib/vips.rb#765
    def set_debug(debug); end

    # Get the number of active allocations.
    #
    # source://vips//lib/vips.rb#672
    def tracked_allocs; end

    # Get the number of open files.
    #
    # source://vips//lib/vips.rb#677
    def tracked_files; end

    # Get the number of bytes currently allocated via vips_malloc.
    #
    # source://vips//lib/vips.rb#662
    def tracked_mem; end

    # Get the greatest number of bytes ever actively allocated via vips_malloc.
    #
    # source://vips//lib/vips.rb#667
    def tracked_mem_highwater; end

    # source://vips//lib/vips/object.rb#163
    def type_find(*_arg0); end

    # Whether SIMD and the run-time compiler are enabled. This can give a nice
    # speed-up, but can also be unstable on some systems or with some versions
    # of the run-time compiler.
    #
    # @return [Boolean]
    #
    # source://vips//lib/vips.rb#750
    def vector?; end

    # Enable or disable SIMD and the run-time compiler. This can give a nice
    # speed-up, but can also be unstable on some systems or with some versions
    # of the run-time compiler.
    #
    # source://vips//lib/vips.rb#757
    def vector_set(enabled); end

    # source://vips//lib/vips.rb#771
    def version(*_arg0); end

    # source://vips//lib/vips.rb#772
    def version_string(*_arg0); end

    # source://vips//lib/vips/image.rb#50
    def vips_addalpha(*args); end

    # source://vips//lib/vips/operation.rb#29
    def vips_argument_map(*_arg0); end

    # source://vips//lib/vips/object.rb#17
    def vips_band_format_get_type(*_arg0); end

    # source://vips//lib/vips/image.rb#59
    def vips_band_format_iscomplex(*_arg0); end

    # source://vips//lib/vips/image.rb#60
    def vips_band_format_isfloat(*_arg0); end

    # source://vips//lib/vips/object.rb#36
    def vips_blend_mode_get_type(*_arg0); end

    # source://vips//lib/vips.rb#659
    def vips_cache_drop_all(*_arg0); end

    # source://vips//lib/vips.rb#652
    def vips_cache_get_max(*_arg0); end

    # source://vips//lib/vips.rb#654
    def vips_cache_get_max_files(*_arg0); end

    # source://vips//lib/vips.rb#653
    def vips_cache_get_max_mem(*_arg0); end

    # source://vips//lib/vips/operation.rb#20
    def vips_cache_operation_build(*_arg0); end

    # source://vips//lib/vips.rb#658
    def vips_cache_print(*_arg0); end

    # source://vips//lib/vips.rb#655
    def vips_cache_set_max(*_arg0); end

    # source://vips//lib/vips.rb#657
    def vips_cache_set_max_files(*_arg0); end

    # source://vips//lib/vips.rb#656
    def vips_cache_set_max_mem(*_arg0); end

    # source://vips//lib/vips/object.rb#19
    def vips_coding_get_type(*_arg0); end

    # source://vips//lib/vips.rb#630
    def vips_concurrency_get(*_arg0); end

    # source://vips//lib/vips.rb#629
    def vips_concurrency_set(*_arg0); end

    # source://vips//lib/vips/connection.rb#11
    def vips_connection_filename(*_arg0); end

    # source://vips//lib/vips/connection.rb#12
    def vips_connection_nick(*_arg0); end

    # source://vips//lib/vips/object.rb#129
    def vips_enum_from_nick(*_arg0); end

    # source://vips//lib/vips/object.rb#130
    def vips_enum_nick(*_arg0); end

    # source://vips//lib/vips.rb#585
    def vips_error_buffer(*_arg0); end

    # source://vips//lib/vips.rb#586
    def vips_error_clear(*_arg0); end

    # source://vips//lib/vips.rb#587
    def vips_error_freeze(*_arg0); end

    # source://vips//lib/vips.rb#588
    def vips_error_thaw(*_arg0); end

    # source://vips//lib/vips/image.rb#20
    def vips_filename_get_filename(*_arg0); end

    # source://vips//lib/vips/image.rb#21
    def vips_filename_get_options(*_arg0); end

    # source://vips//lib/vips/image.rb#23
    def vips_foreign_find_load(*_arg0); end

    # source://vips//lib/vips/image.rb#25
    def vips_foreign_find_load_buffer(*_arg0); end

    # source://vips//lib/vips/image.rb#29
    def vips_foreign_find_load_source(*_arg0); end

    # source://vips//lib/vips/image.rb#24
    def vips_foreign_find_save(*_arg0); end

    # source://vips//lib/vips/image.rb#26
    def vips_foreign_find_save_buffer(*_arg0); end

    # source://vips//lib/vips/image.rb#30
    def vips_foreign_find_save_target(*_arg0); end

    # source://vips//lib/vips.rb#637
    def vips_foreign_get_suffixes(*_arg0); end

    # source://vips//lib/vips/image.rb#15
    def vips_image_copy_memory(*_arg0); end

    # source://vips//lib/vips/image.rb#37
    def vips_image_get(*_arg0); end

    # source://vips//lib/vips/image.rb#42
    def vips_image_get_bands(*_arg0); end

    # source://vips//lib/vips/image.rb#45
    def vips_image_get_fields(*_arg0); end

    # source://vips//lib/vips/image.rb#41
    def vips_image_get_height(*_arg0); end

    # source://vips//lib/vips/image.rb#36
    def vips_image_get_typeof(*_arg0); end

    # source://vips//lib/vips/image.rb#40
    def vips_image_get_width(*_arg0); end

    # source://vips//lib/vips/image.rb#46
    def vips_image_hasalpha(*_arg0); end

    # source://vips//lib/vips/image.rb#64
    def vips_image_invalidate_all(*_arg0); end

    # source://vips//lib/vips/image.rb#66
    def vips_image_new_from_memory(*_arg0); end

    # source://vips//lib/vips/image.rb#67
    def vips_image_new_from_memory_copy(*_arg0); end

    # source://vips//lib/vips/image.rb#12
    def vips_image_new_matrix_from_array(*_arg0); end

    # source://vips//lib/vips/image.rb#57
    def vips_image_remove(*_arg0); end

    # source://vips//lib/vips/image.rb#55
    def vips_image_set(*_arg0); end

    # source://vips//lib/vips/image.rb#18
    def vips_image_set_kill(*_arg0); end

    # source://vips//lib/vips/image.rb#17
    def vips_image_set_progress(*_arg0); end

    # source://vips//lib/vips/image.rb#33
    def vips_image_write_to_memory(*_arg0); end

    # source://vips//lib/vips.rb#617
    def vips_init(*_arg0); end

    # source://vips//lib/vips/interpolate.rb#2
    def vips_interpolate_new(*_arg0); end

    # source://vips//lib/vips/object.rb#18
    def vips_interpretation_get_type(*_arg0); end

    # source://vips//lib/vips.rb#626
    def vips_leak_set(*_arg0); end

    # source://vips//lib/vips/object.rb#328
    def vips_object_get_argument(*_arg0); end

    # source://vips//lib/vips/object.rb#339
    def vips_object_get_description(*_arg0); end

    # source://vips//lib/vips/object.rb#13
    def vips_object_print_all(*_arg0); end

    # source://vips//lib/vips/object.rb#334
    def vips_object_set_from_string(*_arg0); end

    # source://vips//lib/vips/operation.rb#22
    def vips_object_unref_outputs(*_arg0); end

    # source://vips//lib/vips/operation.rb#43
    def vips_operation_get_flags(*_arg0); end

    # source://vips//lib/vips/operation.rb#13
    def vips_operation_new(*_arg0); end

    # source://vips//lib/vips/region.rb#13
    def vips_region_fetch(*_arg0); end

    # source://vips//lib/vips/region.rb#15
    def vips_region_height(*_arg0); end

    # source://vips//lib/vips/region.rb#10
    def vips_region_new(*_arg0); end

    # source://vips//lib/vips/region.rb#14
    def vips_region_width(*_arg0); end

    # source://vips//lib/vips/sourcecustom.rb#11
    def vips_source_custom_new(*_arg0); end

    # source://vips//lib/vips/source.rb#11
    def vips_source_new_from_descriptor(*_arg0); end

    # source://vips//lib/vips/source.rb#12
    def vips_source_new_from_file(*_arg0); end

    # source://vips//lib/vips/source.rb#13
    def vips_source_new_from_memory(*_arg0); end

    # source://vips//lib/vips/targetcustom.rb#11
    def vips_target_custom_new(*_arg0); end

    # source://vips//lib/vips/target.rb#11
    def vips_target_new_to_descriptor(*_arg0); end

    # source://vips//lib/vips/target.rb#12
    def vips_target_new_to_file(*_arg0); end

    # source://vips//lib/vips/target.rb#13
    def vips_target_new_to_memory(*_arg0); end

    # source://vips//lib/vips.rb#650
    def vips_tracked_get_allocs(*_arg0); end

    # source://vips//lib/vips.rb#651
    def vips_tracked_get_files(*_arg0); end

    # source://vips//lib/vips.rb#648
    def vips_tracked_get_mem(*_arg0); end

    # source://vips//lib/vips.rb#649
    def vips_tracked_get_mem_highwater(*_arg0); end

    # source://vips//lib/vips/object.rb#337
    def vips_type_map(*_arg0); end

    # source://vips//lib/vips/object.rb#154
    def vips_value_get_array_double(*_arg0); end

    # source://vips//lib/vips/object.rb#158
    def vips_value_get_array_image(*_arg0); end

    # source://vips//lib/vips/object.rb#156
    def vips_value_get_array_int(*_arg0); end

    # source://vips//lib/vips/object.rb#160
    def vips_value_get_blob(*_arg0); end

    # source://vips//lib/vips/object.rb#152
    def vips_value_get_ref_string(*_arg0); end

    # source://vips//lib/vips/object.rb#134
    def vips_value_set_array_double(*_arg0); end

    # source://vips//lib/vips/object.rb#138
    def vips_value_set_array_image(*_arg0); end

    # source://vips//lib/vips/object.rb#136
    def vips_value_set_array_int(*_arg0); end

    # source://vips//lib/vips/object.rb#141
    def vips_value_set_blob(*_arg0); end

    # source://vips//lib/vips/object.rb#132
    def vips_value_set_ref_string(*_arg0); end

    # source://vips//lib/vips.rb#628
    def vips_vector_isenabled(*_arg0); end

    # source://vips//lib/vips.rb#627
    def vips_vector_set_enabled(*_arg0); end
  end
end

# source://vips//lib/vips/object.rb#291
Vips::ARGUMENT_CONSTRUCT = T.let(T.unsafe(nil), Integer)

# source://vips//lib/vips/object.rb#296
Vips::ARGUMENT_DEPRECATED = T.let(T.unsafe(nil), Integer)

# source://vips//lib/vips/object.rb#299
Vips::ARGUMENT_FLAGS = T.let(T.unsafe(nil), Hash)

# source://vips//lib/vips/object.rb#294
Vips::ARGUMENT_INPUT = T.let(T.unsafe(nil), Integer)

# source://vips//lib/vips/object.rb#297
Vips::ARGUMENT_MODIFY = T.let(T.unsafe(nil), Integer)

# source://vips//lib/vips/object.rb#295
Vips::ARGUMENT_OUTPUT = T.let(T.unsafe(nil), Integer)

# enum VipsArgumentFlags
#
# source://vips//lib/vips/object.rb#290
Vips::ARGUMENT_REQUIRED = T.let(T.unsafe(nil), Integer)

# source://vips//lib/vips/object.rb#293
Vips::ARGUMENT_SET_ALWAYS = T.let(T.unsafe(nil), Integer)

# source://vips//lib/vips/object.rb#292
Vips::ARGUMENT_SET_ONCE = T.let(T.unsafe(nil), Integer)

# source://vips//lib/vips/object.rb#26
Vips::ARRAY_DOUBLE_TYPE = T.let(T.unsafe(nil), Integer)

# source://vips//lib/vips/object.rb#27
Vips::ARRAY_IMAGE_TYPE = T.let(T.unsafe(nil), Integer)

# source://vips//lib/vips/object.rb#25
Vips::ARRAY_INT_TYPE = T.let(T.unsafe(nil), Integer)

# source://vips//lib/vips/object.rb#280
class Vips::Argument < ::FFI::Struct; end

# source://vips//lib/vips/object.rb#310
class Vips::ArgumentClass < ::Vips::Argument; end

# source://vips//lib/vips/object.rb#318
class Vips::ArgumentClassPtr < ::FFI::Struct; end

# source://vips//lib/vips/object.rb#284
class Vips::ArgumentInstance < ::Vips::Argument; end

# source://vips//lib/vips/object.rb#322
class Vips::ArgumentInstancePtr < ::FFI::Struct; end

# source://vips//lib/vips/object.rb#31
Vips::BAND_FORMAT_TYPE = T.let(T.unsafe(nil), Integer)

# source://vips//lib/vips/object.rb#37
Vips::BLEND_MODE_TYPE = T.let(T.unsafe(nil), Integer)

# source://vips//lib/vips/object.rb#29
Vips::BLOB_TYPE = T.let(T.unsafe(nil), Integer)

# source://vips//lib/vips/object.rb#33
Vips::CODING_TYPE = T.let(T.unsafe(nil), Integer)

# Abstract base class for connections.
#
# source://vips//lib/vips/connection.rb#16
class Vips::Connection < ::Vips::Object
  # Get any filename associated with a connection, or nil.
  #
  # source://vips//lib/vips/connection.rb#36
  def filename; end

  # Get a nickname (short description) of a connection that could be shown to
  # the user.
  #
  # source://vips//lib/vips/connection.rb#42
  def nick; end
end

# The layout of the VipsRegion struct.
#
# source://vips//lib/vips/connection.rb#18
module Vips::Connection::ConnectionLayout
  class << self
    # @private
    #
    # source://vips//lib/vips/connection.rb#19
    def included(base); end
  end
end

# source://vips//lib/vips/connection.rb#31
class Vips::Connection::ManagedStruct < ::Vips::Object::ManagedStruct
  include ::Vips::Connection::ConnectionLayout
end

# source://vips//lib/vips/connection.rb#27
class Vips::Connection::Struct < ::Vips::Object::Struct
  include ::Vips::Connection::ConnectionLayout
end

# Track the original default concurrency so we can reset to it.
#
# source://vips//lib/vips.rb#633
Vips::DEFAULT_CONCURRENCY = T.let(T.unsafe(nil), Integer)

# The ruby-vips error class.
#
# source://vips//lib/vips.rb#591
class Vips::Error < ::RuntimeError
  # @param msg [String] The error message. If this is not supplied, grab
  #   and clear the vips error buffer and use that.
  # @return [Error] a new instance of Error
  #
  # source://vips//lib/vips.rb#594
  def initialize(msg = T.unsafe(nil)); end

  # Pretty-print a {Vips::Error}.
  #
  # @return [String] The error message
  #
  # source://vips//lib/vips.rb#608
  def to_s; end
end

# some handy gtypes
#
# source://vips//lib/vips/object.rb#24
Vips::IMAGE_TYPE = T.let(T.unsafe(nil), Integer)

# source://vips//lib/vips/object.rb#32
Vips::INTERPRETATION_TYPE = T.let(T.unsafe(nil), Integer)

# This class represents a libvips image. See the {Vips} module documentation
# for an introduction to using this class.
#
# source://vips//lib/vips/image.rb#80
class Vips::Image < ::Vips::Object
  # Equivalent to image ^ -1
  #
  # @return [Image] image with bits flipped
  #
  # source://vips//lib/vips/image.rb#1076
  def !; end

  # Compare inequality to nil, an image, constant or array.
  #
  # @param other [nil, Image, Real, Array<Real>] test inequality to this
  # @return [Image] result of inequality
  #
  # source://vips//lib/vips/image.rb#1150
  def !=(other); end

  # Remainder after integer division with an image, constant or array.
  #
  # @param other [Image, Real, Array<Real>] self modulo this
  # @return [Image] result of modulo
  #
  # source://vips//lib/vips/image.rb#1020
  def %(other); end

  # Integer bitwise AND with an image, constant or array.
  #
  # @param other [Image, Real, Array<Real>] bitwise AND with this
  # @return [Image] result of bitwise AND
  #
  # source://vips//lib/vips/image.rb#1061
  def &(other); end

  # Multiply an image, constant or array.
  #
  # @param other [Image, Real, Array<Real>] Thing to multiply by self
  # @return [Image] result of multiplication
  #
  # source://vips//lib/vips/image.rb#1002
  def *(other); end

  # Raise to power of an image, constant or array.
  #
  # @param other [Image, Real, Array<Real>] self to the power of this
  # @return [Image] result of power
  #
  # source://vips//lib/vips/image.rb#1029
  def **(other); end

  # Add an image, constant or array.
  #
  # @param other [Image, Real, Array<Real>] Thing to add to self
  # @return [Image] result of addition
  #
  # source://vips//lib/vips/image.rb#984
  def +(other); end

  # @return [Image] image
  #
  # source://vips//lib/vips/image.rb#1088
  def +@; end

  # Subtract an image, constant or array.
  #
  # @param other [Image, Real, Array<Real>] Thing to subtract from self
  # @return [Image] result of subtraction
  #
  # source://vips//lib/vips/image.rb#993
  def -(other); end

  # Equivalent to image * -1
  #
  # @return [Image] negative of image
  #
  # source://vips//lib/vips/image.rb#1095
  def -@; end

  # Divide an image, constant or array.
  #
  # @param other [Image, Real, Array<Real>] Thing to divide self by
  # @return [Image] result of division
  #
  # source://vips//lib/vips/image.rb#1011
  def /(other); end

  # Relational less than with an image, constant or array.
  #
  # @param other [Image, Real, Array<Real>] relational less than with this
  # @return [Image] result of less than
  #
  # source://vips//lib/vips/image.rb#1103
  def <(other); end

  # Integer left shift with an image, constant or array.
  #
  # @param other [Image, Real, Array<Real>] shift left by this much
  # @return [Image] result of left shift
  #
  # source://vips//lib/vips/image.rb#1037
  def <<(other); end

  # Relational less than or equal to with an image, constant or array.
  #
  # @param other [Image, Real, Array<Real>] relational less than or
  #   equal to with this
  # @return [Image] result of less than or equal to
  #
  # source://vips//lib/vips/image.rb#1112
  def <=(other); end

  # Compare equality to nil, an image, constant or array.
  #
  # @param other [nil, Image, Real, Array<Real>] test equality to this
  # @return [Image] result of equality
  #
  # source://vips//lib/vips/image.rb#1137
  def ==(other); end

  # Relational more than with an image, constant or array.
  #
  # @param other [Image, Real, Array<Real>] relational more than with this
  # @return [Image] result of more than
  #
  # source://vips//lib/vips/image.rb#1120
  def >(other); end

  # Relational more than or equal to with an image, constant or array.
  #
  # @param other [Image, Real, Array<Real>] relational more than or
  #   equal to with this
  # @return [Image] result of more than or equal to
  #
  # source://vips//lib/vips/image.rb#1129
  def >=(other); end

  # Integer right shift with an image, constant or array.
  #
  # @param other [Image, Real, Array<Real>] shift right by this much
  # @return [Image] result of right shift
  #
  # source://vips//lib/vips/image.rb#1045
  def >>(other); end

  # Fetch bands using a number or a range
  #
  # @param index [Numeric, Range] extract these band(s)
  # @return [Image] extracted band(s)
  #
  # source://vips//lib/vips/image.rb#1163
  def [](index); end

  # Integer bitwise EOR with an image, constant or array.
  #
  # @param other [Image, Real, Array<Real>] bitwise EOR with this
  # @return [Image] result of bitwise EOR
  #
  # source://vips//lib/vips/image.rb#1069
  def ^(other); end

  # Return the inverse cosine of an image in degrees.
  #
  # @return [Image] inverse cosine of each pixel
  #
  # source://vips//lib/vips/image.rb#1425
  def acos; end

  # Return the inverse hyperbolic cosine of an image in radians.
  #
  # @return [Image] inverse cosine of each pixel
  #
  # source://vips//lib/vips/image.rb#1467
  def acosh; end

  # Append an alpha channel to an image.
  #
  # @raise [Vips::Error]
  # @return [Image] new image
  #
  # source://vips//lib/vips/image.rb#950
  def add_alpha; end

  # Return the inverse sine of an image in degrees.
  #
  # @return [Image] inverse sine of each pixel
  #
  # source://vips//lib/vips/image.rb#1418
  def asin; end

  # Return the inverse hyperbolic sine of an image in radians.
  #
  # @return [Image] inverse sine of each pixel
  #
  # source://vips//lib/vips/image.rb#1460
  def asinh; end

  # Return the inverse tangent of an image in degrees.
  #
  # @return [Image] inverse tangent of each pixel
  #
  # source://vips//lib/vips/image.rb#1432
  def atan; end

  # Return the inverse hyperbolic tangent of an image in radians.
  #
  # @return [Image] inverse tangent of each pixel
  #
  # source://vips//lib/vips/image.rb#1474
  def atanh; end

  # AND the bands of an image together
  #
  # @return [Image] all bands ANDed together
  #
  # source://vips//lib/vips/image.rb#1234
  def bandand; end

  # EOR the bands of an image together
  #
  # @return [Image] all bands EORed together
  #
  # source://vips//lib/vips/image.rb#1248
  def bandeor; end

  # Join a set of images bandwise.
  #
  # @param other [Image, Array<Image>, Real, Array<Real>] bands to append
  # @return [Image] many band image
  #
  # source://vips//lib/vips/image.rb#1263
  def bandjoin(other); end

  # OR the bands of an image together
  #
  # @return [Image] all bands ORed together
  #
  # source://vips//lib/vips/image.rb#1241
  def bandor; end

  # Get number of image bands.
  #
  # @return [Integer] number of image bands
  #
  # source://vips//lib/vips/image.rb#851
  def bands; end

  # Split an n-band image into n separate images.
  #
  # @return [Array<Image>] Array of n one-band images
  #
  # source://vips//lib/vips/image.rb#1255
  def bandsplit; end

  # Return the smallest integral value not less than the argument.
  #
  # @return [Image] ceil of image
  #
  # source://vips//lib/vips/image.rb#1220
  def ceil; end

  # source://vips//lib/vips/image.rb#83
  def close; end

  # Get image coding.
  #
  # @return [Symbol] image coding
  #
  # source://vips//lib/vips/image.rb#872
  def coding; end

  # Composite a set of images with a set of blend modes.
  #
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @param overlay [Image, Array<Image>] images to composite
  # @param mode [BlendMode, Array<BlendMode>] blend modes to use
  # @param opts [Hash] Set of options
  # @return [Image] blended image
  #
  # source://vips//lib/vips/image.rb#1289
  def composite(overlay, mode, **options); end

  # Return the complex conjugate of an image.
  #
  # The image
  # can be complex, in which case the return image will also be complex,
  # or must have an even number of bands, in which case pairs of
  # bands are treated as (x, y) coordinates.
  #
  # @return [Image] complex conjugate
  #
  # source://vips//lib/vips/image.rb#1382
  def conj; end

  # Copy an image to a memory area.
  #
  # This can be useful for reusing results, but can obviously use a lot of
  # memory for large images. See {Image#tilecache} for a way of caching
  # parts of an image.
  #
  # @return [Image] new memory image
  #
  # source://vips//lib/vips/image.rb#966
  def copy_memory; end

  # Return the cosine of an image in degrees.
  #
  # @return [Image] cosine of each pixel
  #
  # source://vips//lib/vips/image.rb#1404
  def cos; end

  # Return the hyperbolic cosine of an image in radians.
  #
  # @return [Image] cosine of each pixel
  #
  # source://vips//lib/vips/image.rb#1446
  def cosh; end

  # Calculate the cross phase of two images.
  #
  # @param other [Image, Real, Array<Real>] cross phase with this
  # @return [Image] cross phase
  #
  # source://vips//lib/vips/image.rb#1390
  def cross_phase(other); end

  # Dilate with a structuring element.
  #
  # The structuring element must be an array with 0 for black, 255 for
  # white and 128 for don't care.
  #
  # @param mask [Image, Array<Real>, Array<Array<Real>>] structuring
  #   element
  # @return [Image] dilated image
  #
  # source://vips//lib/vips/image.rb#1540
  def dilate(mask); end

  # Draw a point on an image.
  #
  # See {Image#draw_rect}.
  #
  # @return [Image] modified image
  #
  # source://vips//lib/vips/image.rb#976
  def draw_point(ink, left, top, **opts); end

  # Erode with a structuring element.
  #
  # The structuring element must be an array with 0 for black, 255 for
  # white and 128 for don't care.
  #
  # @param mask [Image, Array<Real>, Array<Array<Real>>] structuring
  #   element
  # @return [Image] eroded image
  #
  # source://vips//lib/vips/image.rb#1528
  def erode(mask); end

  # Return e ** pixel.
  #
  # @return [Image] e ** pixel
  #
  # source://vips//lib/vips/image.rb#1495
  def exp; end

  # Return 10 ** pixel.
  #
  # @return [Image] 10 ** pixel
  #
  # source://vips//lib/vips/image.rb#1502
  def exp10; end

  # Get image filename, if any.
  #
  # @return [String] image filename
  #
  # source://vips//lib/vips/image.rb#879
  def filename; end

  # Flip horizontally.
  #
  # @return [Image] image flipped horizontally
  #
  # source://vips//lib/vips/image.rb#1509
  def fliphor; end

  # Flip vertically.
  #
  # @return [Image] image flipped vertically
  #
  # source://vips//lib/vips/image.rb#1516
  def flipver; end

  # Return the largest integral value not greater than the argument.
  #
  # @return [Image] floor of image
  #
  # source://vips//lib/vips/image.rb#1213
  def floor; end

  # Get image format.
  #
  # @return [Symbol] image format
  #
  # source://vips//lib/vips/image.rb#858
  def format; end

  # Get a metadata item from an image. Ruby types are constructed
  # automatically from the `GValue`, if possible.
  #
  # For example, you can read the ICC profile from an image like this:
  #
  # ```
  # profile = image.get "icc-profile-data"
  # ```
  #
  # and profile will be an array containing the profile.
  #
  # @param name [String] Metadata field to get
  # @raise [Vips::Error]
  # @return [Object] Value of field
  #
  # source://vips//lib/vips/image.rb#739
  def get(name); end

  # Get the names of all fields on an image. Use this to loop over all
  # image metadata.
  #
  # @return [[String]] array of field names
  #
  # source://vips//lib/vips/image.rb#758
  def get_fields; end

  # Get the `GType` of a metadata field. The result is 0 if no such field
  # exists.
  #
  # @param name [String] Metadata field to fetch
  # @return [Integer] GType
  # @see get
  #
  # source://vips//lib/vips/image.rb#715
  def get_typeof(name); end

  # compatibility: old name for get
  #
  # source://vips//lib/vips/image.rb#823
  def get_value(name); end

  # Detect if image has an alpha channel
  #
  # @return [Boolean] true if image has an alpha channel.
  #
  # source://vips//lib/vips/image.rb#940
  def has_alpha?; end

  # Get image height, in pixels.
  #
  # @return [Integer] image height, in pixels
  #
  # source://vips//lib/vips/image.rb#844
  def height; end

  # Select pixels from `th` if `self` is non-zero and from `el` if
  # `self` is zero. Use the `:blend` option to fade smoothly
  # between `th` and `el`.
  #
  # @option opts
  # @param th [Image, Real, Array<Real>] true values
  # @param el [Image, Real, Array<Real>] false values
  # @param opts [Hash] set of options
  # @return [Image] merged image
  #
  # source://vips//lib/vips/image.rb#1574
  def ifthenelse(th, el, **opts); end

  # Return the imaginary part of a complex image.
  #
  # @return [Image] imaginary part of complex image
  #
  # source://vips//lib/vips/image.rb#1344
  def imag; end

  # source://vips//lib/vips/image.rb#172
  def inspect; end

  # Get image interpretation.
  #
  # @return [Symbol] image interpretation
  #
  # source://vips//lib/vips/image.rb#865
  def interpretation; end

  # Return the natural log of an image.
  #
  # @return [Image] natural log of each pixel
  #
  # source://vips//lib/vips/image.rb#1481
  def log; end

  # Return the log base 10 of an image.
  #
  # @return [Image] base 10 log of each pixel
  #
  # source://vips//lib/vips/image.rb#1488
  def log10; end

  # Return the coordinates of the image maximum.
  #
  # @return [Real, Real, Real] maximum value, x coordinate of maximum, y
  #   coordinate of maximum
  #
  # source://vips//lib/vips/image.rb#1308
  def maxpos; end

  # a median filter
  #
  # @param size [Integer] size of filter window
  # @return [Image] result of median filter
  #
  # source://vips//lib/vips/image.rb#1330
  def median(size = T.unsafe(nil)); end

  # Invoke a vips operation with {Vips::Operation.call}, using self as
  # the first input argument.
  #
  # @param name [String] vips operation to call
  # @return result of vips operation
  #
  # source://vips//lib/vips/image.rb#206
  def method_missing(name, *args, **options); end

  # Return the coordinates of the image minimum.
  #
  # @return [Real, Real, Real] minimum value, x coordinate of minimum, y
  #   coordinate of minimum
  #
  # source://vips//lib/vips/image.rb#1319
  def minpos; end

  # Mutate an image with a block. Inside the block, you can call methods
  # which modify the image, such as setting or removing metadata, or
  # modifying pixels.
  #
  # For example:
  #
  # ```ruby
  # image = image.mutate do |x|
  #   (0 ... 1).step(0.01) do |i|
  #     x.draw_line! 255, x.width * i, 0, 0, x.height * (1 - i)
  #   end
  # end
  # ```
  #
  # See {MutableImage}.
  #
  # @yield [mutable]
  #
  # source://vips//lib/vips/image.rb#791
  def mutate; end

  # A new image is created with the same width, height, format,
  # interpretation, resolution and offset as self, but with every pixel
  # set to the specified value.
  #
  # You can pass an array to make a many-band image, or a single value to
  # make a one-band image.
  #
  # @param value [Real, Array<Real>] value to put in each pixel
  # @return [Image] constant image
  #
  # source://vips//lib/vips/image.rb#526
  def new_from_image(value); end

  # Get offset metadata.
  #
  # @return [Float] image offset
  #
  # source://vips//lib/vips/image.rb#923
  def offset; end

  # source://vips//lib/vips/image.rb#81
  def parent_get_typeof(name); end

  # Return an image with rectangular pixels converted to polar.
  #
  # The image
  # can be complex, in which case the return image will also be complex,
  # or must have an even number of bands, in which case pairs of
  # bands are treated as (x, y) coordinates.
  #
  # @return [Image] image converted to polar coordinates
  # @see xyz
  #
  # source://vips//lib/vips/image.rb#1357
  def polar; end

  # Return the real part of a complex image.
  #
  # @return [Image] real part of complex image
  #
  # source://vips//lib/vips/image.rb#1337
  def real; end

  # Return an image with polar pixels converted to rectangular.
  #
  # The image
  # can be complex, in which case the return image will also be complex,
  # or must have an even number of bands, in which case pairs of
  # bands are treated as (x, y) coordinates.
  #
  # @return [Image] image converted to rectangular coordinates
  # @see xyz
  #
  # source://vips//lib/vips/image.rb#1370
  def rect; end

  # This method is deprecated.
  #
  # Please use {MutableImage#remove!} instead.
  #
  # source://vips//lib/vips/image.rb#818
  def remove(name); end

  # @return [Boolean]
  #
  # source://vips//lib/vips/image.rb#176
  def respond_to?(name, include_all = T.unsafe(nil)); end

  # Return the nearest integral value.
  #
  # @return [Image] rint of image
  #
  # source://vips//lib/vips/image.rb#1227
  def rint; end

  # Rotate by 180 degrees clockwise.
  #
  # @return [Image] rotated image
  #
  # source://vips//lib/vips/image.rb#1554
  def rot180; end

  # Rotate by 270 degrees clockwise.
  #
  # @return [Image] rotated image
  #
  # source://vips//lib/vips/image.rb#1561
  def rot270; end

  # Rotate by 90 degrees clockwise.
  #
  # @return [Image] rotated image
  #
  # source://vips//lib/vips/image.rb#1547
  def rot90; end

  # Get scale metadata.
  #
  # @return [Float] image scale
  #
  # source://vips//lib/vips/image.rb#914
  def scale; end

  # Scale an image to uchar. This is the vips `scale` operation, but
  # renamed to avoid a clash with the `.scale` property.
  #
  # @param opts [Hash] Set of options
  # @return [Vips::Image] Output image
  #
  # source://vips//lib/vips/image.rb#1592
  def scaleimage(**options); end

  # This method is deprecated.
  #
  # Please use {MutableImage#set!} instead.
  #
  # source://vips//lib/vips/image.rb#811
  def set(name, value); end

  # Kill computation of this time.
  #
  # Set true to stop computation of this image. You can call this from a
  # progress handler, for example.
  #
  # @param kill [Boolean] stop computation
  # @see Object#signal_connect
  #
  # source://vips//lib/vips/image.rb#705
  def set_kill(kill); end

  # Turn progress signalling on and off.
  #
  # If this is on, the most-downstream image from this image will issue
  # progress signals.
  #
  # @param state [Boolean] progress signalling state
  # @see Object#signal_connect
  #
  # source://vips//lib/vips/image.rb#694
  def set_progress(state); end

  # This method is deprecated.
  #
  # Please use {MutableImage#set_type!} instead.
  #
  # source://vips//lib/vips/image.rb#800
  def set_type(gtype, name, value); end

  # This method is deprecated.
  #
  # Please use {MutableImage#set!} instead.
  #
  # source://vips//lib/vips/image.rb#830
  def set_value(name, value); end

  # Return the sine of an image in degrees.
  #
  # @return [Image] sine of each pixel
  #
  # source://vips//lib/vips/image.rb#1397
  def sin; end

  # Return the hyperbolic sine of an image in radians.
  #
  # @return [Image] sine of each pixel
  #
  # source://vips//lib/vips/image.rb#1439
  def sinh; end

  # Get the image size.
  #
  # @return [Integer, Integer] image width and height
  #
  # source://vips//lib/vips/image.rb#932
  def size; end

  # Return the tangent of an image in degrees.
  #
  # @return [Image] tangent of each pixel
  #
  # source://vips//lib/vips/image.rb#1411
  def tan; end

  # Return the hyperbolic tangent of an image in radians.
  #
  # @return [Image] tangent of each pixel
  #
  # source://vips//lib/vips/image.rb#1453
  def tanh; end

  # Convert to an Array. This will be slow for large images.
  #
  # @return [Array] Array of Arrays of Arrays of Numerics
  #
  # source://vips//lib/vips/image.rb#1206
  def to_a; end

  # Convert to an Enumerator. Similar to `#to_a` but lazier.
  #
  # @return [Enumerator] Enumerator of Enumerators of Arrays of Numerics
  #
  # source://vips//lib/vips/image.rb#1177
  def to_enum; end

  # Get image width, in pixels.
  #
  # @return [Integer] image width, in pixels
  #
  # source://vips//lib/vips/image.rb#837
  def width; end

  # Write this image to a memory buffer. Save options may be encoded in
  # the format_string or given as a hash. For example:
  #
  # ```
  # buffer = image.write_to_buffer ".jpg[Q=90]"
  # ```
  #
  # or equivalently:
  #
  # ```
  # image.write_to_buffer ".jpg", Q: 90
  # ```
  #
  # The full set of save options depend on the selected saver. Try
  # something like:
  #
  # ```
  # $ vips jpegsave
  # ```
  #
  # to see all the available options for JPEG save.
  #
  # @option opts
  # @option opts
  # @param format_string [String] save format plus options
  # @param opts [Hash] set of options
  # @raise [Vips::Error]
  # @return [String] the image saved in the specified format
  #
  # source://vips//lib/vips/image.rb#600
  def write_to_buffer(format_string, **opts); end

  # Write this image to a file. Save options may be encoded in the
  # filename or given as a hash. For example:
  #
  # ```
  # image.write_to_file "fred.jpg[Q=90]"
  # ```
  #
  # or equivalently:
  #
  # ```
  # image.write_to_file "fred.jpg", Q: 90
  # ```
  #
  # The full set of save options depend on the selected saver. Try
  # something like:
  #
  # ```
  # $ vips jpegsave
  # ```
  #
  # to see all the available options for JPEG save.
  #
  # @option opts
  # @option opts
  # @param opts [Hash] set of options
  # @param name [String] filename to write to
  # @raise [Vips::Error]
  #
  # source://vips//lib/vips/image.rb#562
  def write_to_file(name, **opts); end

  # Write this image to a large memory buffer.
  #
  # @raise [Vips::Error]
  # @return [String] the pixels as a huge binary string
  #
  # source://vips//lib/vips/image.rb#672
  def write_to_memory; end

  # Write this image to a target. Save options may be encoded in
  # the format_string or given as a hash. For example:
  #
  # ```ruby
  # target = Vips::Target.new_to_file "k2.jpg"
  # image.write_to_target target, ".jpg[Q=90]"
  # ```
  #
  # or equivalently:
  #
  # ```ruby
  # image.write_to_target target, ".jpg", Q: 90
  # ```
  #
  # The full set of save options depend on the selected saver. Try
  # something like:
  #
  # ```
  # $ vips jpegsave_target
  # ```
  #
  # to see all the available options for JPEG save.
  #
  # @option opts
  # @option opts
  # @param target [Vips::Target] the target to write to
  # @param format_string [String] save format plus string options
  # @param opts [Hash] set of options
  # @raise [Vips::Error]
  #
  # source://vips//lib/vips/image.rb#657
  def write_to_target(target, format_string, **opts); end

  # Get image xoffset.
  #
  # @return [Integer] image xoffset
  #
  # source://vips//lib/vips/image.rb#886
  def xoffset; end

  # Get image x resolution.
  #
  # @return [Float] image x resolution
  #
  # source://vips//lib/vips/image.rb#900
  def xres; end

  # Get image yoffset.
  #
  # @return [Integer] image yoffset
  #
  # source://vips//lib/vips/image.rb#893
  def yoffset; end

  # Get image y resolution.
  #
  # @return [Float] image y resolution
  #
  # source://vips//lib/vips/image.rb#907
  def yres; end

  # Integer bitwise OR with an image, constant or array.
  #
  # @param other [Image, Real, Array<Real>] bitwise OR with this
  # @return [Image] result of bitwise OR
  #
  # source://vips//lib/vips/image.rb#1053
  def |(other); end

  # Equivalent to image ^ -1
  #
  # @return [Image] image with bits flipped
  #
  # source://vips//lib/vips/image.rb#1083
  def ~; end

  private

  # handy for expanding enum operations
  #
  # source://vips//lib/vips/image.rb#162
  def call_enum(name, other, enum); end

  # @return [Boolean]
  #
  # source://vips//lib/vips/image.rb#187
  def respond_to_missing?(name, include_all = T.unsafe(nil)); end

  class << self
    # @return [Boolean]
    #
    # source://vips//lib/vips/image.rb#122
    def complex?(format); end

    # @return [Boolean]
    #
    # source://vips//lib/vips/image.rb#127
    def float?(format); end

    # source://vips//lib/vips/image.rb#442
    def matrix_from_array(width, height, array); end

    # Invoke a vips operation with {Vips::Operation.call}.
    #
    # source://vips//lib/vips/image.rb#211
    def method_missing(name, *args, **options); end

    # Create a new Image from a 1D or 2D array. A 1D array becomes an
    # image with height 1. Use `scale` and `offset` to set the scale and
    # offset fields in the header. These are useful for integer
    # convolutions.
    #
    # For example:
    #
    # ```
    # image = Vips::Image.new_from_array [1, 2, 3]
    # ```
    #
    # or
    #
    # ```
    # image = Vips::Image.new_from_array [
    #     [-1, -1, -1],
    #     [-1, 16, -1],
    #     [-1, -1, -1]], 8
    # ```
    #
    # for a simple sharpening mask.
    #
    # @param array [Array] the pixel data as an array of numbers
    # @param scale [Real] the convolution scale
    # @param offset [Real] the convolution offset
    # @raise [Vips::Error]
    # @return [Image] the image
    #
    # source://vips//lib/vips/image.rb#476
    def new_from_array(array, scale = T.unsafe(nil), offset = T.unsafe(nil)); end

    # Create a new {Image} for an image encoded in a format such as
    # JPEG in a binary string. Load options may be passed as
    # strings or appended as a hash. For example:
    #
    # ```
    # image = Vips::Image.new_from_buffer memory_buffer, "shrink=2"
    # ```
    #
    # or alternatively:
    #
    # ```
    # image = Vips::Image.new_from_buffer memory_buffer, "", shrink: 2
    # ```
    #
    # The options available depend on the file format. Try something like:
    #
    # ```
    # $ vips jpegload_buffer
    # ```
    #
    # at the command-line to see the available options. Not all loaders
    # support load from buffer, but at least JPEG, PNG and
    # TIFF images will work.
    #
    # Loading is fast: only enough of the image is loaded to be able to fill
    # out the header. Pixels will only be decompressed when they are needed.
    #
    # @option opts
    # @option opts
    # @param data [String] the data to load from
    # @param option_string [String] load options as a string
    # @param opts [Hash] set of options
    # @raise [Vips::Error]
    # @return [Image] the loaded image
    #
    # source://vips//lib/vips/image.rb#295
    def new_from_buffer(data, option_string, **opts); end

    # Return a new {Image} for a file on disc. This method can load
    # images in any format supported by vips. The filename can include
    # load options, for example:
    #
    # ```
    # image = Vips::Image.new_from_file "fred.jpg[shrink=2]"
    # ```
    #
    # You can also supply options as a hash, for example:
    #
    # ```
    # image = Vips::Image.new_from_file "fred.jpg", shrink: 2
    # ```
    #
    # The full set of options available depend upon the load operation that
    # will be executed. Try something like:
    #
    # ```
    # $ vips jpegload
    # ```
    #
    # at the command-line to see a summary of the available options for the
    # JPEG loader.
    #
    # Loading is fast: only enough of the image is loaded to be able to fill
    # out the header. Pixels will only be decompressed when they are needed.
    #
    # @option opts
    # @option opts
    # @param name [String] the filename to load from
    # @param opts [Hash] set of options
    # @raise [Vips::Error]
    # @return [Image] the loaded image
    #
    # source://vips//lib/vips/image.rb#251
    def new_from_file(name, **opts); end

    # Create a new {Image} from a C-style array held in memory. For example:
    #
    # ```
    # image = Vips::Image.black(16, 16) + 128
    # data = image.write_to_memory
    #
    # x = Vips::Image.new_from_memory data,
    #   image.width, image.height, image.bands, image.format
    # ```
    #
    # Creating a new image from a memory pointer:
    #
    # ```
    # ptr = FFI::MemoryPointer.new(:uchar, 10*10)
    # # => #<FFI::MemoryPointer address=0x00007fc236db31d0 size=100>
    # x = Vips::Image.new_from_memory(ptr, 10, 10, 1, :uchar)
    # ```
    #
    # Creating a new image from an address only pointer:
    #
    # ```
    # ptr = call_to_external_c_library(w: 10, h: 10)
    # # => #<FFI::Pointer address=0x00007f9780813a00>
    # ptr_slice = ptr.slice(0, 10*10)
    # # => #<FFI::Pointer address=0x00007f9780813a00 size=100>
    # x = Vips::Image.new_from_memory(ptr_slice, 10, 10, 1, :uchar)
    # ```
    #
    # {new_from_memory} keeps a reference to the array of pixels you pass in
    # to try to prevent that memory from being freed by the Ruby GC while it
    # is being used.
    #
    # See {new_from_memory_copy} for a version of this method which does not
    # keep a reference.
    #
    # @param data [String, FFI::Pointer] the data to load from
    # @param width [Integer] width in pixels
    # @param height [Integer] height in pixels
    # @param bands [Integer] number of bands
    # @param format [Symbol] band format
    # @raise [Vips::Error]
    # @return [Image] the loaded image
    #
    # source://vips//lib/vips/image.rb#343
    def new_from_memory(data, width, height, bands, format); end

    # Create a new {Image} from memory and copies the memory area. See
    # {new_from_memory} for a version of this method which does not copy the
    # memory area.
    #
    # @param data [String, FFI::Pointer] the data to load from
    # @param width [Integer] width in pixels
    # @param height [Integer] height in pixels
    # @param bands [Integer] number of bands
    # @param format [Symbol] band format
    # @raise [Vips::Error]
    # @return [Image] the loaded image
    #
    # source://vips//lib/vips/image.rb#385
    def new_from_memory_copy(data, width, height, bands, format); end

    # Create a new {Image} from a source. Load options may be passed as
    # strings or appended as a hash. For example:
    #
    # ```
    # source = Vips::Source.new_from_file("k2.jpg")
    # image = Vips::Image.new_from_source source, "shrink=2"
    # ```
    #
    # or alternatively:
    #
    # ```
    # image = Vips::Image.new_from_source source, "", shrink: 2
    # ```
    #
    # The options available depend on the file format. Try something like:
    #
    # ```
    # $ vips jpegload_source
    # ```
    #
    # at the command-line to see the available options. Not all loaders
    # support load from source, but at least JPEG, PNG and
    # TIFF images will work.
    #
    # Loading is fast: only enough data is read to be able to fill
    # out the header. Pixels will only be read and decompressed when they are
    # needed.
    #
    # @option opts
    # @option opts
    # @param source [Vips::Source] the source to load from
    # @param option_string [String] load options as a string
    # @param opts [Hash] set of options
    # @raise [Vips::Error]
    # @return [Image] the loaded image
    #
    # source://vips//lib/vips/image.rb#435
    def new_from_source(source, option_string, **opts); end

    # @return [Boolean]
    #
    # source://vips//lib/vips/image.rb#194
    def respond_to_missing?(name, include_all = T.unsafe(nil)); end

    # run a complex operation on a complex image, or an image with an even
    # number of bands ... handy for things like running .polar on .index
    # images
    #
    # source://vips//lib/vips/image.rb#135
    def run_cmplx(image, &block); end

    # handy for overloads ... want to be able to apply a function to an
    # array or to a scalar
    #
    # source://vips//lib/vips/image.rb#118
    def smap(x, &block); end
  end
end

# source://vips//lib/vips/image.rb#112
class Vips::Image::GenericPtr < ::FFI::Struct; end

# the layout of the VipsImage struct
#
# source://vips//lib/vips/image.rb#95
module Vips::Image::ImageLayout
  class << self
    # @private
    #
    # source://vips//lib/vips/image.rb#96
    def included(base); end
  end
end

# source://vips//lib/vips/image.rb#108
class Vips::Image::ManagedStruct < ::Vips::Object::ManagedStruct
  include ::Vips::Image::ImageLayout
end

# source://vips//lib/vips/image.rb#104
class Vips::Image::Struct < ::Vips::Object::Struct
  include ::Vips::Image::ImageLayout
end

# FFI sets a pointer's size to this magic value if the size of the memory
# chunk the pointer points to is unknown to FFI.
#
# source://vips//lib/vips/image.rb#89
Vips::Image::UNKNOWN_POINTER_SIZE = T.let(T.unsafe(nil), Integer)

# source://vips//lib/vips/object.rb#148
class Vips::IntStruct < ::FFI::Struct; end

# An interpolator. One of these can be given to operations like
# {Image#affine} or {Image#mapim} to select the type of pixel interpolation
# to use.
#
# To see all interpolators supported by your
# libvips, try
#
# ```
# $ vips -l interpolate
# ```
#
# But at least these should be available:
#
# *   `:nearest` Nearest-neighbour interpolation.
# *   `:bilinear` Bilinear interpolation.
# *   `:bicubic` Bicubic interpolation.
# *   `:lbb` Reduced halo bicubic interpolation.
# *   `:nohalo` Edge sharpening resampler with halo reduction.
# *   `:vsqbs` B-Splines with antialiasing smoothing.
#
#  For example:
#
#  ```ruby
#  im = im.affine [2, 0, 0, 2],
#      :interpolate => Vips::Interpolate.new(:bicubic)
#  ```
#
# source://vips//lib/vips/interpolate.rb#31
class Vips::Interpolate < ::Vips::Object
  # @raise [Vips::Error]
  # @return [Interpolate] a new instance of Interpolate
  #
  # source://vips//lib/vips/interpolate.rb#50
  def initialize(name); end
end

# the layout of the VipsInterpolate struct
#
# source://vips//lib/vips/interpolate.rb#33
module Vips::Interpolate::InterpolateLayout
  class << self
    # @private
    #
    # source://vips//lib/vips/interpolate.rb#34
    def included(base); end
  end
end

# source://vips//lib/vips/interpolate.rb#46
class Vips::Interpolate::ManagedStruct < ::Vips::Object::ManagedStruct
  include ::Vips::Interpolate::InterpolateLayout
end

# source://vips//lib/vips/interpolate.rb#42
class Vips::Interpolate::Struct < ::Vips::Object::Struct
  include ::Vips::Interpolate::InterpolateLayout
end

# Introspect a vips operation and return a large structure containing
# everything we know about it. This is used for doc generation as well as
# call.
#
# source://vips//lib/vips/operation.rb#48
class Vips::Introspect
  # @return [Introspect] a new instance of Introspect
  #
  # source://vips//lib/vips/operation.rb#56
  def initialize(name); end

  # Yard comment generation needs a little more introspection. We add this
  # extra metadata in a separate method to keep the main path as fast as
  # we can.
  #
  # source://vips//lib/vips/operation.rb#140
  def add_yard_introspection(name); end

  # Returns the value of attribute args.
  #
  # source://vips//lib/vips/operation.rb#49
  def args; end

  # Returns the value of attribute description.
  #
  # source://vips//lib/vips/operation.rb#49
  def description; end

  # Returns the value of attribute destructive.
  #
  # source://vips//lib/vips/operation.rb#49
  def destructive; end

  # Returns the value of attribute doc_optional_input.
  #
  # source://vips//lib/vips/operation.rb#49
  def doc_optional_input; end

  # Returns the value of attribute doc_optional_output.
  #
  # source://vips//lib/vips/operation.rb#49
  def doc_optional_output; end

  # Returns the value of attribute flags.
  #
  # source://vips//lib/vips/operation.rb#49
  def flags; end

  # Returns the value of attribute member_x.
  #
  # source://vips//lib/vips/operation.rb#49
  def member_x; end

  # Returns the value of attribute method_args.
  #
  # source://vips//lib/vips/operation.rb#49
  def method_args; end

  # Returns the value of attribute name.
  #
  # source://vips//lib/vips/operation.rb#49
  def name; end

  # Returns the value of attribute optional_input.
  #
  # source://vips//lib/vips/operation.rb#49
  def optional_input; end

  # Returns the value of attribute optional_output.
  #
  # source://vips//lib/vips/operation.rb#49
  def optional_output; end

  # Returns the value of attribute required_input.
  #
  # source://vips//lib/vips/operation.rb#49
  def required_input; end

  # Returns the value of attribute required_output.
  #
  # source://vips//lib/vips/operation.rb#49
  def required_output; end

  # Returns the value of attribute vips_name.
  #
  # source://vips//lib/vips/operation.rb#49
  def vips_name; end

  class << self
    # source://vips//lib/vips/operation.rb#183
    def get(name); end

    # source://vips//lib/vips/operation.rb#187
    def get_yard(name); end
  end
end

# source://vips//lib/vips.rb#804
Vips::LIBRARY_VERSION = T.let(T.unsafe(nil), String)

# source://vips//lib/vips.rb#575
Vips::LOG_DOMAIN = T.let(T.unsafe(nil), String)

# map signal name to marshal proc
#
# source://vips//lib/vips/object.rb#119
Vips::MARSHAL_ALL = T.let(T.unsafe(nil), Hash)

# source://vips//lib/vips/object.rb#111
Vips::MARSHAL_FINISH = T.let(T.unsafe(nil), Proc)

# Our signal marshalers.
#
# These are functions which take the handler as a param and return a
# closure with the right FFI signature for g_signal_connect for this
# specific signal.
#
# ruby-ffi makes it hard to use the g_signal_connect user data param
# to pass the function pointer through, unfortunately.
#
# We can't throw exceptions across C, so we must catch everything.
#
# source://vips//lib/vips/object.rb#65
Vips::MARSHAL_PROGRESS = T.let(T.unsafe(nil), Proc)

# source://vips//lib/vips/object.rb#72
Vips::MARSHAL_READ = T.let(T.unsafe(nil), Proc)

# source://vips//lib/vips/object.rb#85
Vips::MARSHAL_SEEK = T.let(T.unsafe(nil), Proc)

# source://vips//lib/vips/object.rb#98
Vips::MARSHAL_WRITE = T.let(T.unsafe(nil), Proc)

# libvips has this arbitrary number as a sanity-check upper bound on image
# size. It's sometimes useful to know when calculating scale factors.
#
# source://vips//lib/vips.rb#808
Vips::MAX_COORD = T.let(T.unsafe(nil), Integer)

# This class represents a libvips image which can be modified. See
# {Vips::Image#mutate}.
#
# source://vips//lib/vips/mutableimage.rb#13
class Vips::MutableImage < ::Vips::Object
  # Make a {MutableImage} from a regular {Image}.
  #
  # This is for internal use only. See {Vips::Image#mutate} for the
  # user-facing interface.
  #
  # @return [MutableImage] a new instance of MutableImage
  #
  # source://vips//lib/vips/mutableimage.rb#50
  def initialize(image); end

  # source://vips//lib/vips/mutableimage.rb#16
  def bands(*args, **_arg1, &block); end

  # Draw a point on an image.
  #
  # See {Image#draw_rect}.
  #
  # source://vips//lib/vips/mutableimage.rb#102
  def draw_point!(ink, left, top, **opts); end

  # source://vips//lib/vips/mutableimage.rb#16
  def filename(*args, **_arg1, &block); end

  # source://vips//lib/vips/mutableimage.rb#16
  def format(*args, **_arg1, &block); end

  # source://vips//lib/vips/mutableimage.rb#16
  def get(*args, **_arg1, &block); end

  # source://vips//lib/vips/mutableimage.rb#16
  def get_fields(*args, **_arg1, &block); end

  # source://vips//lib/vips/mutableimage.rb#16
  def get_typeof(*args, **_arg1, &block); end

  # source://vips//lib/vips/mutableimage.rb#16
  def height(*args, **_arg1, &block); end

  # Get the {Image} this {MutableImage} is modifying. Only use this once you
  # have finished all modifications.
  #
  # This is for internal use only. See {Vips::Image#mutate} for the
  # user-facing interface.
  #
  # source://vips//lib/vips/mutableimage.rb#44
  def image; end

  # source://vips//lib/vips/mutableimage.rb#67
  def inspect; end

  # source://vips//lib/vips/mutableimage.rb#16
  def interpretation(*args, **_arg1, &block); end

  # Invoke a vips operation with {Vips::Operation#call}, using self as
  # the first input argument. {Vips::Operation#call} will only allow
  # operations that modify self when passed a {MutableImage}.
  #
  # @param name [String] vips operation to call
  # @return result of vips operation
  #
  # source://vips//lib/vips/mutableimage.rb#95
  def method_missing(name, *args, **options); end

  # source://vips//lib/vips/mutableimage.rb#15
  def parent_get_typeof(name); end

  # Remove a metadata item from an image.
  #
  # For example:
  #
  # ```
  # x.remove! "icc-profile-data"
  # ```
  #
  # @param name [String] Metadata field to remove
  #
  # source://vips//lib/vips/mutableimage.rb#172
  def remove!(name); end

  # @return [Boolean]
  #
  # source://vips//lib/vips/mutableimage.rb#71
  def respond_to?(name, include_all = T.unsafe(nil)); end

  # Set the value of a metadata item on an image. The metadata item must
  # already exist. Ruby types are automatically transformed into the
  # matching {GObject::GValue}, if possible.
  #
  # For example, you can use this to set an image's ICC profile:
  #
  # ```
  # x.set! "icc-profile-data", profile
  # ```
  #
  # where `profile` is an ICC profile held as a binary string object.
  #
  # @param name [String] Metadata field to set
  # @param value [Object] Value to set
  # @see set_type!
  #
  # source://vips//lib/vips/mutableimage.rb#159
  def set!(name, value); end

  # Create a metadata item on an image of the specifed type. Ruby types
  # are automatically transformed into the matching glib type (eg.
  # {GObject::GINT_TYPE}), if possible.
  #
  # For example, you can use this to set an image's ICC profile:
  #
  # ```ruby
  # x.set_type! Vips::BLOB_TYPE, "icc-profile-data", profile
  # ```
  #
  # where `profile` is an ICC profile held as a binary string object.
  #
  # @param gtype [Integer] GType of item
  # @param name [String] Metadata field to set
  # @param value [Object] Value to set
  # @see set!
  #
  # source://vips//lib/vips/mutableimage.rb#122
  def set_type!(gtype, name, value); end

  # source://vips//lib/vips/mutableimage.rb#16
  def size(*args, **_arg1, &block); end

  # source://vips//lib/vips/mutableimage.rb#16
  def width(*args, **_arg1, &block); end

  # source://vips//lib/vips/mutableimage.rb#16
  def xoffset(*args, **_arg1, &block); end

  # source://vips//lib/vips/mutableimage.rb#16
  def xres(*args, **_arg1, &block); end

  # source://vips//lib/vips/mutableimage.rb#16
  def yoffset(*args, **_arg1, &block); end

  # source://vips//lib/vips/mutableimage.rb#16
  def yres(*args, **_arg1, &block); end

  private

  # @return [Boolean]
  #
  # source://vips//lib/vips/mutableimage.rb#82
  def respond_to_missing?(name, include_all = T.unsafe(nil)); end
end

# source://vips//lib/vips/mutableimage.rb#35
class Vips::MutableImage::ManagedStruct < ::Vips::Object::ManagedStruct
  include ::Vips::MutableImage::MutableImageLayout
end

# layout is exactly as {Image} (since we are also wrapping a VipsImage
# object)
#
# source://vips//lib/vips/mutableimage.rb#22
module Vips::MutableImage::MutableImageLayout
  class << self
    # @private
    #
    # source://vips//lib/vips/mutableimage.rb#23
    def included(base); end
  end
end

# source://vips//lib/vips/mutableimage.rb#31
class Vips::MutableImage::Struct < ::Vips::Object::Struct
  include ::Vips::MutableImage::MutableImageLayout
end

# source://vips//lib/vips/operation.rb#35
Vips::OPERATION_DEPRECATED = T.let(T.unsafe(nil), Integer)

# source://vips//lib/vips/operation.rb#37
Vips::OPERATION_FLAGS = T.let(T.unsafe(nil), Hash)

# source://vips//lib/vips/operation.rb#34
Vips::OPERATION_NOCACHE = T.let(T.unsafe(nil), Integer)

# source://vips//lib/vips/operation.rb#33
Vips::OPERATION_SEQUENTIAL = T.let(T.unsafe(nil), Integer)

# source://vips//lib/vips/object.rb#165
class Vips::Object < ::GObject::GObject
  # source://vips//lib/vips/object.rb#233
  def get(name); end

  # return a pspec, or nil ... nil wil leave a message in the error log
  # which you must clear
  #
  # source://vips//lib/vips/object.rb#202
  def get_pspec(name); end

  # return a gtype, 0 on not found
  #
  # source://vips//lib/vips/object.rb#223
  def get_typeof(name); end

  # return a gtype, raise an error on not found
  #
  # @raise [Vips::Error]
  #
  # source://vips//lib/vips/object.rb#215
  def get_typeof_error(name); end

  # source://vips//lib/vips/object.rb#246
  def set(name, value); end

  # @raise [Vips::Error]
  #
  # source://vips//lib/vips/object.rb#257
  def signal_connect(name, handler = T.unsafe(nil), &block); end

  class << self
    # print all active VipsObjects, with their reference counts. Handy for
    # debugging ruby-vips.
    #
    # source://vips//lib/vips/object.rb#168
    def print_all; end
  end
end

# source://vips//lib/vips/object.rb#196
class Vips::Object::ManagedStruct < ::GObject::GObject::ManagedStruct
  include ::Vips::Object::ObjectLayout
end

# the layout of the VipsObject struct
#
# source://vips//lib/vips/object.rb#174
module Vips::Object::ObjectLayout
  class << self
    # @private
    #
    # source://vips//lib/vips/object.rb#175
    def included(base); end
  end
end

# source://vips//lib/vips/object.rb#192
class Vips::Object::Struct < ::GObject::GObject::Struct
  include ::Vips::Object::ObjectLayout
end

# source://vips//lib/vips/object.rb#276
class Vips::ObjectClass < ::FFI::Struct; end

# source://vips//lib/vips/operation.rb#194
class Vips::Operation < ::Vips::Object
  # @return [Operation] a new instance of Operation
  #
  # source://vips//lib/vips/operation.rb#213
  def initialize(value); end

  # source://vips//lib/vips/operation.rb#234
  def argument_map(&block); end

  # source://vips//lib/vips/operation.rb#224
  def build; end

  # set an operation argument, expanding constants and copying images as
  # required
  #
  # source://vips//lib/vips/operation.rb#273
  def set(name, value, match_image, flags, gtype, destructive); end

  class << self
    # This is the public entry point for the vips binding. {call} will run
    # any vips operation, for example:
    #
    # ```ruby
    # out = Vips::Operation.call "black", [100, 100], {:bands => 12}
    # ```
    #
    # will call the C function
    #
    # ```C
    # vips_black( &out, 100, 100, "bands", 12, NULL );
    # ```
    #
    # There are {Image#method_missing} hooks which will run {call} for you
    # on {Image} for undefined instance or class methods. So you can also
    # write:
    #
    # ```ruby
    # out = Vips::Image.black 100, 100, bands: 12
    # ```
    #
    # Or perhaps:
    #
    # ```ruby
    # x = Vips::Image.black 100, 100
    # y = x.invert
    # ```
    #
    # to run the `vips_invert()` operator.
    #
    # There are also a set of operator overloads and some convenience
    # functions, see {Image}.
    #
    # If the operator needs a vector constant, {call} will turn a scalar
    # into a
    # vector for you. So for `x.linear a, b`, which calculates
    # `x * a + b` where `a` and `b` are vector constants, you can write:
    #
    # ```ruby
    # x = Vips::Image.black 100, 100, bands: 3
    # y = x.linear 1, 2
    # y = x.linear [1], 4
    # y = x.linear [1, 2, 3], 4
    # ```
    #
    # or any other combination. The operator overloads use this facility to
    # support all the variations on:
    #
    # ```ruby
    # x = Vips::Image.black 100, 100, bands: 3
    # y = x * 2
    # y = x + [1,2,3]
    # y = x % [1]
    # ```
    #
    # Similarly, wherever an image is required, you can use a constant. The
    # constant will be expanded to an image matching the first input image
    # argument. For example, you can write:
    #
    # ```
    # x = Vips::Image.black 100, 100, bands: 3
    # y = x.bandjoin 255
    # ```
    #
    # to add an extra band to the image where each pixel in the new band has
    # the constant value 255.
    #
    # source://vips//lib/vips/operation.rb#358
    def call(name, supplied, optional = T.unsafe(nil), option_string = T.unsafe(nil)); end

    # Search an object for the first element to match a predicate. Search
    # inside subarrays and sub-hashes. Equlvalent to x.flatten.find{}.
    #
    # source://vips//lib/vips/operation.rb#243
    def flat_find(object, &block); end

    # expand a constant into an image
    #
    # source://vips//lib/vips/operation.rb#257
    def imageize(match_image, value); end
  end
end

# source://vips//lib/vips/operation.rb#209
class Vips::Operation::ManagedStruct < ::Vips::Object::ManagedStruct
  include ::Vips::Operation::OperationLayout
end

# the layout of the VipsOperation struct
#
# source://vips//lib/vips/operation.rb#196
module Vips::Operation::OperationLayout
  class << self
    # @private
    #
    # source://vips//lib/vips/operation.rb#197
    def included(base); end
  end
end

# source://vips//lib/vips/operation.rb#205
class Vips::Operation::Struct < ::Vips::Object::Struct
  include ::Vips::Operation::OperationLayout
end

# source://vips//lib/vips/object.rb#44
class Vips::Progress < ::FFI::Struct; end

# source://vips//lib/vips/object.rb#28
Vips::REFSTR_TYPE = T.let(T.unsafe(nil), Integer)

# A region on an image. Create one, then use `fetch` to quickly get a region
# of pixels.
#
# For example:
#
#  ```ruby
#  region = Vips::Region.new(image)
#  pixels = region.fetch(10, 10, 100, 100)
#  ```
#
# source://vips//lib/vips/region.rb#27
class Vips::Region < ::Vips::Object
  # @raise [Vips::Error]
  # @return [Region] a new instance of Region
  #
  # source://vips//lib/vips/region.rb#46
  def initialize(name); end

  # Fetch a region filled with pixel data.
  #
  # @raise [Vips::Error]
  #
  # source://vips//lib/vips/region.rb#62
  def fetch(left, top, width, height); end

  # source://vips//lib/vips/region.rb#57
  def height; end

  # source://vips//lib/vips/region.rb#53
  def width; end
end

# source://vips//lib/vips/region.rb#42
class Vips::Region::ManagedStruct < ::Vips::Object::ManagedStruct
  include ::Vips::Region::RegionLayout
end

# The layout of the VipsRegion struct.
#
# source://vips//lib/vips/region.rb#29
module Vips::Region::RegionLayout
  class << self
    # @private
    #
    # source://vips//lib/vips/region.rb#30
    def included(base); end
  end
end

# source://vips//lib/vips/region.rb#38
class Vips::Region::Struct < ::Vips::Object::Struct
  include ::Vips::Region::RegionLayout
end

# source://vips//lib/vips/object.rb#144
class Vips::SizeStruct < ::FFI::Struct; end

# A source. For example:
#
# ```ruby
# source = Vips::Source.new_from_file("k2.jpg")
# image = Vips::Image.new_from_source(source)
# ```
#
# source://vips//lib/vips/source.rb#22
class Vips::Source < ::Vips::Connection
  class << self
    # Create a new source from a file descriptor. File descriptors are
    # small integers, for example 0 is stdin.
    #
    # Pass sources to {Image.new_from_source} to load images from
    # them.
    #
    # @param descriptor [Integer] the file descriptor
    # @raise [Vips::Error]
    # @return [Source] the new Vips::Source
    #
    # source://vips//lib/vips/source.rb#48
    def new_from_descriptor(descriptor); end

    # Create a new source from a file name.
    #
    # Pass sources to {Image.new_from_source} to load images from
    # them.
    #
    # @param filename [String] the name of the file
    # @raise [Vips::Error]
    # @return [Source] the new Vips::Source
    #
    # source://vips//lib/vips/source.rb#62
    def new_from_file(filename); end

    # Create a new source from an area of memory. Memory areas can be
    # strings, arrays and so forth -- anything that supports bytesize.
    #
    # Pass sources to {Image.new_from_source} to load images from
    # them.
    #
    # @param data [String] memory area
    # @raise [Vips::Error]
    # @return [Source] the new Vips::Source
    #
    # source://vips//lib/vips/source.rb#78
    def new_from_memory(data); end
  end
end

# source://vips//lib/vips/source.rb#36
class Vips::Source::ManagedStruct < ::Vips::Connection::ManagedStruct
  include ::Vips::Source::SourceLayout
end

# source://vips//lib/vips/source.rb#23
module Vips::Source::SourceLayout
  class << self
    # @private
    #
    # source://vips//lib/vips/source.rb#24
    def included(base); end
  end
end

# source://vips//lib/vips/source.rb#32
class Vips::Source::Struct < ::Vips::Connection::Struct
  include ::Vips::Source::SourceLayout
end

# A source you can attach action signal handlers to to implement
# custom input types.
#
# For example:
#
# ```ruby
# file = File.open "some/file/name", "rb"
# source = Vips::SourceCustom.new
# source.on_read { |length| file.read length }
# image = Vips::Image.new_from_source source
# ```
#
# (just an example -- of course in practice you'd use {Source#new_from_file}
# to read from a named file)
#
# source://vips//lib/vips/sourcecustom.rb#28
class Vips::SourceCustom < ::Vips::Source
  # @raise [Vips::Error]
  # @return [SourceCustom] a new instance of SourceCustom
  #
  # source://vips//lib/vips/sourcecustom.rb#46
  def initialize; end

  # The block is executed to read data from the source. The interface is
  # exactly as IO::read, ie. it takes a maximum number of bytes to read and
  # returns a string of bytes from the source, or nil if the source is already
  # at end of file.
  #
  # @yieldparam length [Integer] Read and return up to this many bytes
  # @yieldreturn [String] Up to length bytes of data, or nil for EOF
  #
  # source://vips//lib/vips/sourcecustom.rb#60
  def on_read(&block); end

  # The block is executed to seek the source. The interface is exactly as
  # IO::seek, ie. it should take an offset and whence, and return the
  # new read position.
  #
  # This handler is optional -- if you do not attach a seek handler,
  # {Source} will treat your source like an unseekable pipe object and
  # do extra caching.
  #
  # @yieldparam offset [Integer] Seek offset
  # @yieldparam whence [Integer] Seek whence
  # @yieldreturn [Integer] the new read position, or -1 on error
  #
  # source://vips//lib/vips/sourcecustom.rb#83
  def on_seek(&block); end
end

# source://vips//lib/vips/sourcecustom.rb#42
class Vips::SourceCustom::ManagedStruct < ::Vips::Source::ManagedStruct
  include ::Vips::SourceCustom::SourceCustomLayout
end

# source://vips//lib/vips/sourcecustom.rb#29
module Vips::SourceCustom::SourceCustomLayout
  class << self
    # @private
    #
    # source://vips//lib/vips/sourcecustom.rb#30
    def included(base); end
  end
end

# source://vips//lib/vips/sourcecustom.rb#38
class Vips::SourceCustom::Struct < ::Vips::Source::Struct
  include ::Vips::SourceCustom::SourceCustomLayout
end

# A target. For example:
#
# ```ruby
# target = Vips::Target.new_to_file('k2.jpg')
# image.write_to_target(target, '.jpg')
# ```
#
# source://vips//lib/vips/target.rb#22
class Vips::Target < ::Vips::Connection
  class << self
    # Create a new target to a file descriptor. File descriptors are
    # small integers, for example 1 is stdout.
    #
    # Pass targets to {Image#write_to_target} to write images to
    # them.
    #
    # @param descriptor [Integer] the file descriptor
    # @raise [Vips::Error]
    # @return [Target] the new Vips::Target
    #
    # source://vips//lib/vips/target.rb#49
    def new_to_descriptor(descriptor); end

    # Create a new target to a file name.
    #
    # Pass targets to {Image#write_to_target} to write images to
    # them.
    #
    # @param filename [String] the name of the file
    # @raise [Vips::Error]
    # @return [Target] the new Vips::Target
    #
    # source://vips//lib/vips/target.rb#63
    def new_to_file(filename); end

    # Create a new target to an area of memory.
    #
    # Pass targets to {Image#write_to_target} to write images to
    # them.
    #
    # Once the image has been written, use {Object#get}`("blob")` to read out
    # the data.
    #
    # @return [Target] the new Vips::Target
    #
    # source://vips//lib/vips/target.rb#80
    def new_to_memory; end
  end
end

# source://vips//lib/vips/target.rb#37
class Vips::Target::ManagedStruct < ::Vips::Connection::ManagedStruct
  include ::Vips::Target::TargetLayout
end

# source://vips//lib/vips/target.rb#33
class Vips::Target::Struct < ::Vips::Connection::Struct
  include ::Vips::Target::TargetLayout
end

# The layout of the VipsRegion struct.
#
# source://vips//lib/vips/target.rb#24
module Vips::Target::TargetLayout
  class << self
    # @private
    #
    # source://vips//lib/vips/target.rb#25
    def included(base); end
  end
end

# A target you can attach action signal handlers to to implememt
# custom output types.
#
# For example:
#
# ```ruby
# file = File.open "some/file/name", "wb"
# target = Vips::TargetCustom.new
# target.on_write { |bytes| file.write bytes }
# image.write_to_target target, ".png"
# ```
#
# (just an example -- of course in practice you'd use {Target#new_to_file}
# to write to a named file)
#
# source://vips//lib/vips/targetcustom.rb#28
class Vips::TargetCustom < ::Vips::Target
  # @raise [Vips::Error]
  # @return [TargetCustom] a new instance of TargetCustom
  #
  # source://vips//lib/vips/targetcustom.rb#46
  def initialize; end

  # The block is executed at the end of write. It should do any necessary
  # finishing action, such as closing a file.
  #
  # source://vips//lib/vips/targetcustom.rb#71
  def on_finish(&block); end

  # The block is executed to write data to the source. The interface is
  # exactly as IO::write, ie. it should write the string and return the
  # number of bytes written.
  #
  # @yieldparam bytes [String] Write these bytes to the file
  # @yieldreturn [Integer] The number of bytes written, or -1 on error
  #
  # source://vips//lib/vips/targetcustom.rb#59
  def on_write(&block); end
end

# source://vips//lib/vips/targetcustom.rb#42
class Vips::TargetCustom::ManagedStruct < ::Vips::Target::ManagedStruct
  include ::Vips::TargetCustom::TargetCustomLayout
end

# source://vips//lib/vips/targetcustom.rb#38
class Vips::TargetCustom::Struct < ::Vips::Target::Struct
  include ::Vips::TargetCustom::TargetCustomLayout
end

# source://vips//lib/vips/targetcustom.rb#29
module Vips::TargetCustom::TargetCustomLayout
  class << self
    # @private
    #
    # source://vips//lib/vips/targetcustom.rb#30
    def included(base); end
  end
end

# source://vips//lib/vips/version.rb#3
Vips::VERSION = T.let(T.unsafe(nil), String)

# This module generates yard comments for all the dynamically bound
# vips operations.
#
# Regenerate with something like:
#
# ```
# $ ruby > methods.rb
# require "vips"; Vips::Yard.generate
# ^D
# ```
#
# source://vips//lib/vips/image.rb#1610
module Vips::Yard
  class << self
    # source://vips//lib/vips/image.rb#1722
    def generate; end

    # source://vips//lib/vips/image.rb#1654
    def generate_operation(introspect); end

    # turn a gtype into a ruby type name
    #
    # source://vips//lib/vips/image.rb#1638
    def gtype_to_ruby(gtype); end
  end
end

# these are aliased (appear under several names)
#
# source://vips//lib/vips/image.rb#1635
Vips::Yard::ALIAS = T.let(T.unsafe(nil), Array)

# map gobject's type names to Ruby
#
# source://vips//lib/vips/image.rb#1612
Vips::Yard::MAP_GO_TO_RUBY = T.let(T.unsafe(nil), Hash)

# these have hand-written methods, see above
#
# source://vips//lib/vips/image.rb#1632
Vips::Yard::NO_GENERATE = T.let(T.unsafe(nil), Array)
