# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/graphql-batch/all/graphql-batch.rbi
#
# graphql-batch-0.5.1

module GraphQL
end
module GraphQL::Batch
  def self.batch(executor_class: nil); end
  def self.use(schema_defn, executor_class: nil); end
end
class GraphQL::Batch::Loader
  def cache; end
  def cache_key(load_key); end
  def check_for_broken_promises(load_keys); end
  def executor; end
  def executor=(arg0); end
  def finish_resolve(key); end
  def fulfill(key, value); end
  def fulfilled?(key); end
  def load(key); end
  def load_many(keys); end
  def loader_key; end
  def loader_key=(arg0); end
  def perform(keys); end
  def promise_for(load_key); end
  def queue; end
  def reject(key, reason); end
  def reject_pending_promises(load_keys, err); end
  def resolve; end
  def resolved?; end
  def self.current_executor; end
  def self.for(*, **, &); end
  def self.load(key); end
  def self.load_many(keys); end
  def self.loader_key_for(*group_args, **group_kwargs); end
  def wait; end
end
class GraphQL::Batch::Executor
  def around_promise_callbacks; end
  def clear; end
  def decrement_level; end
  def increment_level; end
  def initialize; end
  def loader(key); end
  def loading; end
  def resolve(loader); end
  def self.current; end
  def self.current=(executor); end
  def self.end_batch; end
  def self.start_batch(executor_class); end
  def tick; end
  def wait_all; end
end
class GraphQL::Batch::SetupMultiplex
  def after_multiplex(multiplex); end
  def before_multiplex(multiplex); end
  def initialize(schema, executor_class:); end
end
class GraphQL::Batch::NoExecutorError < StandardError
end
class GraphQL::Batch::MutationFieldExtension < GraphQL::Schema::FieldExtension
  def resolve(object:, arguments:, **_rest); end
end
