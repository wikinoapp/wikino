# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rubocop-graphql` gem.
# Please instead update this file by running `bin/tapioca gem rubocop-graphql`.

module RuboCop; end
module RuboCop::Cop; end

# This cop checks whether type definitions are class-based or legacy.
#
# @example
#   # good
#
#   class Example < BaseType
#   ....
#   end
#
#   # bad
#
#   Example = GraphQL::ObjectType.define do
#   ....
#   ....
#   end
module RuboCop::Cop::GraphQL; end

# This cop checks if each field has a description.
#
# @example
#   # good
#
#   class BanUser < BaseMutation
#   argument :uuid, ID, required: true, description: "UUID of the user to ban"
#   end
#
#   # bad
#
#   class BanUser < BaseMutation
#   argument :uuid, ID, required: true
#   end
class RuboCop::Cop::GraphQL::ArgumentDescription < ::RuboCop::Cop::Base
  include ::RuboCop::GraphQL::NodePattern

  def on_send(node); end
end

RuboCop::Cop::GraphQL::ArgumentDescription::MSG = T.let(T.unsafe(nil), String)

# This cop checks whether field names are snake_case.
#
# @example
#   # good
#
#   class BanUser < BaseMutation
#   argument :user_id, ID, required: true
#   end
#
#   # bad
#
#   class BanUser < BaseMutation
#   argument :userId, ID, required: true
#   end
class RuboCop::Cop::GraphQL::ArgumentName < ::RuboCop::Cop::Base
  include ::RuboCop::GraphQL::NodePattern

  def on_send(node); end
end

RuboCop::Cop::GraphQL::ArgumentName::MSG = T.let(T.unsafe(nil), String)

# This cop detects duplicate argument definitions
#
# @example
#   # good
#
#   class BanUser < BaseMutation
#   argument :user_id, ID, required: true
#   end
#
#   # bad
#
#   class BanUser < BaseMutation
#   argument :user_id, ID, required: true
#   argument :user_id, ID, required: true
#   end
class RuboCop::Cop::GraphQL::ArgumentUniqueness < ::RuboCop::Cop::Base
  include ::RuboCop::GraphQL::NodeUniqueness

  def argument_declarations(param0); end
  def on_class(node); end

  private

  def argument_name(node); end

  # Find parent field block, if available
  def field_name(node); end

  def register_offense(current); end
end

RuboCop::Cop::GraphQL::ArgumentUniqueness::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::GraphQL::ExtractInputType < ::RuboCop::Cop::Base
  include ::RuboCop::GraphQL::NodePattern

  def on_class(node); end
end

RuboCop::Cop::GraphQL::ExtractInputType::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::GraphQL::ExtractType < ::RuboCop::Cop::Base
  include ::RuboCop::GraphQL::NodePattern

  def on_class(node); end

  private

  def check_fields_prefixes(body); end
  def fractured(body); end

  # @return [Boolean]
  def ignored_prefix?(word); end

  def message(prefix, field_names); end
end

RuboCop::Cop::GraphQL::ExtractType::MSG = T.let(T.unsafe(nil), String)

# This cop checks consistency of field definitions
#
# EnforcedStyle supports two modes:
#
# `group_definitions` : all field definitions should be grouped together.
#
# `define_resolver_after_definition` : if resolver method exists it should
# be defined right after the field definition.
#
# @example EnforcedStyle: group_definitions (default)
#   # good
#
#   class UserType < BaseType
#   field :first_name, String, null: true
#   field :last_name, String, null: true
#
#   def first_name
#   object.contact_data.first_name
#   end
#
#   def last_name
#   object.contact_data.last_name
#   end
#   end
# @example EnforcedStyle: define_resolver_after_definition
#   # good
#
#   class UserType < BaseType
#   field :first_name, String, null: true
#
#   def first_name
#   object.contact_data.first_name
#   end
#
#   field :last_name, String, null: true
#
#   def last_name
#   object.contact_data.last_name
#   end
#   end
class RuboCop::Cop::GraphQL::FieldDefinitions < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::GraphQL::NodePattern
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::GraphQL::Sorbet
  include ::RuboCop::GraphQL::Heredoc
  extend ::RuboCop::Cop::AutoCorrector

  def field_kwargs(param0 = T.unsafe(nil)); end
  def on_class(node); end
  def on_send(node); end

  private

  def check_grouped_field_declarations(body); end
  def check_resolver_is_defined_after_definition(field); end
  def fields_with_same_resolver(field, resolver); end
  def group_field_declarations(corrector, node); end
  def indent(node); end
  def insert_new_resolver(corrector, field_definition, resolver_definition); end
  def offense_message(single_field_using_resolver); end
  def place_resolver_after_field_definition(corrector, node); end
  def remove_old_resolver(corrector, resolver_definition); end

  # @return [Boolean]
  def resolver_defined_after_definition?(field, method_definition); end

  def signature_to_insert(node); end
end

RuboCop::Cop::GraphQL::FieldDefinitions::GROUP_DEFS_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::GraphQL::FieldDefinitions::RESOLVER_AFTER_FIELD_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::GraphQL::FieldDefinitions::RESOLVER_AFTER_LAST_FIELD_MSG = T.let(T.unsafe(nil), String)

# This cop checks if each field has a description.
#
# @example
#   # good
#
#   class UserType < BaseType
#   field :name, String, "Name of the user", null: true
#   end
#
#   # bad
#
#   class UserType < BaseType
#   field :name, String, null: true
#   end
class RuboCop::Cop::GraphQL::FieldDescription < ::RuboCop::Cop::Base
  include ::RuboCop::GraphQL::NodePattern

  def on_send(node); end
end

RuboCop::Cop::GraphQL::FieldDescription::MSG = T.let(T.unsafe(nil), String)

# This cop prevents defining unnecessary resolver methods in cases
#  when :hash_key option can be used
#
# @example
#   # good
#
#   class Types::UserType < Types::BaseObject
#   field :phone, String, null: true, hash_key: :home_phone
#   end
#
#   # bad
#
#   class Types::UserType < Types::BaseObject
#   field :phone, String, null: true
#
#   def phone
#   object[:home_phone]
#   end
#   end
class RuboCop::Cop::GraphQL::FieldHashKey < ::RuboCop::Cop::Base
  include ::RuboCop::GraphQL::NodePattern
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def hash_key_to_use(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def autocorrect(corrector, node); end
  def message(hash_key); end
  def resolver_method_definition_for(field); end
end

RuboCop::Cop::GraphQL::FieldHashKey::MSG = T.let(T.unsafe(nil), String)

# This cop prevents defining unnecessary resolver methods in cases
#  when :method option can be used
#
# @example
#   # good
#
#   class Types::UserType < Types::BaseObject
#   field :phone, String, null: true, method: :home_phone
#   end
#
#   # bad
#
#   class Types::UserType < Types::BaseObject
#   field :phone, String, null: true
#
#   def phone
#   object.home_phone
#   end
#   end
class RuboCop::Cop::GraphQL::FieldMethod < ::RuboCop::Cop::Base
  include ::RuboCop::GraphQL::NodePattern
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def method_to_use(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def autocorrect(corrector, node); end
  def message(method_name); end
  def suggest_method_name_for(field); end
end

RuboCop::Cop::GraphQL::FieldMethod::MSG = T.let(T.unsafe(nil), String)

# This cop checks whether field names are snake_case.
#
# @example
#   # good
#
#   class UserType < BaseType
#   field :first_name, String, null: true
#   end
#
#   # bad
#
#   class UserType < BaseType
#   field :firstName, String, null: true
#   end
class RuboCop::Cop::GraphQL::FieldName < ::RuboCop::Cop::Base
  include ::RuboCop::GraphQL::NodePattern
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end

  private

  def rename_field_name(corrector, field, node); end
end

RuboCop::Cop::GraphQL::FieldName::MSG = T.let(T.unsafe(nil), String)

# This cop detects duplicate field definitions within
# the same type
#
# @example
#   # good
#
#   class UserType < BaseType
#   field :name, String, null: true
#   field :phone, String, null: true do
#   argument :something, String, required: false
#   end
#   end
#
#   # bad
#
#   class UserType < BaseType
#   field :name, String, null: true
#   field :phone, String, null: true
#   field :phone, String, null: true do
#   argument :something, String, required: false
#   end
#   end
class RuboCop::Cop::GraphQL::FieldUniqueness < ::RuboCop::Cop::Base
  include ::RuboCop::GraphQL::NodeUniqueness

  def field_declarations(param0); end
  def on_class(node); end

  private

  def field_name(node); end
  def register_offense(current); end
end

RuboCop::Cop::GraphQL::FieldUniqueness::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::GraphQL::LegacyDsl < ::RuboCop::Cop::Base
  def legacy_dsl?(param0 = T.unsafe(nil)); end
  def on_send(node); end
end

RuboCop::Cop::GraphQL::LegacyDsl::MSG = T.let(T.unsafe(nil), String)

# This cop checks if a type (object, input, interface, scalar, union,
#  mutation, subscription, and resolver) has a description.
#
# @example
#   # good
#
#   class Types::UserType < Types::BaseObject
#   description "Represents application user"
#   # ...
#   end
#
#   # bad
#
#   class Types::UserType < Types::BaseObject
#   # ...
#   end
class RuboCop::Cop::GraphQL::ObjectDescription < ::RuboCop::Cop::Base
  include ::RuboCop::GraphQL::NodePattern
  include ::RuboCop::GraphQL::DescriptionMethod

  def has_i18n_description?(param0 = T.unsafe(nil)); end
  def interface?(param0 = T.unsafe(nil)); end
  def on_class(node); end
  def on_module(node); end

  private

  def child_nodes(node); end

  # @return [Boolean]
  def has_description?(node); end
end

RuboCop::Cop::GraphQL::ObjectDescription::MSG = T.let(T.unsafe(nil), String)

# Arguments should be alphabetically sorted within groups.
#
# @example
#   # good
#
#   class UpdateProfile < BaseMutation
#   argument :email, String, required: false
#   argument :name, String, required: false
#   end
#
#   # good
#
#   class UpdateProfile < BaseMutation
#   argument :uuid, ID, required: true
#
#   argument :email, String, required: false
#   argument :name, String, required: false
#   end
#
#   # good
#
#   class UserType < BaseType
#   field :posts, PostType do
#   argument :created_after, ISO8601DateTime, required: false
#   argument :created_before, ISO8601DateTime, required: false
#   end
#   end
#
#   # bad
#
#   class UpdateProfile < BaseMutation
#   argument :uuid, ID, required: true
#   argument :name, String, required: false
#   argument :email, String, required: false
#   end
#
#   # bad
#
#   class UserType < BaseType
#   field :posts, PostType do
#   argument :created_before, ISO8601DateTime, required: false
#   argument :created_after, ISO8601DateTime, required: false
#   end
#   end
class RuboCop::Cop::GraphQL::OrderedArguments < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::GraphQL::SwapRange
  extend ::RuboCop::Cop::AutoCorrector

  def argument_declarations_with_blocks(param0); end
  def argument_declarations_without_blocks(param0); end
  def on_class(node); end

  private

  def argument_name(node); end
  def consecutive_lines(previous, current); end
  def register_offense(previous, current); end
end

RuboCop::Cop::GraphQL::OrderedArguments::MSG = T.let(T.unsafe(nil), String)

# Fields should be alphabetically sorted within groups.
#
# @example
#   # good
#
#   class UserType < BaseType
#   field :name, String, null: true
#   field :phone, String, null: true do
#   argument :something, String, required: false
#   end
#   end
#
#   # good
#
#   class UserType < BaseType
#   field :phone, String, null: true
#
#   field :name, String, null: true
#   end
#
#   # bad
#
#   class UserType < BaseType
#   field :phone, String, null: true
#   field :name, String, null: true
#   end
class RuboCop::Cop::GraphQL::OrderedFields < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::GraphQL::SwapRange
  extend ::RuboCop::Cop::AutoCorrector

  def field_declarations(param0); end
  def on_class(node); end

  private

  def consecutive_lines(previous, current); end
  def field_name(node); end
  def register_offense(previous, current); end
end

RuboCop::Cop::GraphQL::OrderedFields::MSG = T.let(T.unsafe(nil), String)

# This cop checks if the length of a resolver method exceeds some maximum value.
# Comment lines can optionally be ignored.
#
# The maximum allowed length is configurable using the Max option.
class RuboCop::Cop::GraphQL::ResolverMethodLength < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableMax
  include ::RuboCop::Cop::CodeLength

  def field_definition(param0 = T.unsafe(nil)); end
  def on_def(node); end
  def on_defs(node); end

  private

  def code_length(node); end

  # @return [Boolean]
  def field_is_defined?(node); end

  def message(length); end
end

RuboCop::Cop::GraphQL::ResolverMethodLength::MSG = T.let(T.unsafe(nil), String)

# Arguments should either be listed explicitly or **rest should be in the resolve signature.
#
# @example
#   # good
#
#   class SomeResolver < Resolvers::Base
#   argument :arg1, String, required: true
#   argument :user_id, String, required: true, loads: Types::UserType
#   argument :post_id, String, loads: Types::PostType, as: :article
#   argument :comment_ids, String, loads: Types::CommentType
#
#   def resolve(arg1:, user:, article:, comments:); end
#   end
#
#   # good
#
#   class SomeResolver < Resolvers::Base
#   argument :arg1, String, required: true
#   argument :user_id, String, required: true, loads: Types::UserType
#   argument :comment_ids, String, loads: Types::CommentType
#
#   def resolve(arg1:, **rest); end
#   end
#
#   # good
#
#   class SomeResolver < Resolvers::Base
#   type SomeType, null: false
#
#   argument :arg1, String, required: true
#   argument :arg2, String, required: true
#
#   def resolve(args); end
#   end
#
#   # bad
#
#   class SomeResolver < Resolvers::Base
#   type SomeType, null: false
#
#   argument :arg1, String, required: true
#   argument :arg2, String, required: true
#
#   def resolve(arg1:); end
#   end
#
#   # bad
#
#   class SomeResolver < Resolvers::Base
#   type SomeType, null: false
#
#   argument :arg1, String, required: true
#   argument :arg2, String, required: true
#
#   def resolve; end
#   end
class RuboCop::Cop::GraphQL::UnusedArgument < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def argument_declaration?(param0 = T.unsafe(nil)); end
  def on_class(node); end
  def resolve_method_definition(param0); end

  private

  def arg_end(node); end
  def arg_name(declared_arg); end

  # @return [Boolean]
  def block_or_lambda?(node); end

  def find_declared_arg_nodes(node); end
  def find_resolve_method_node(node); end
  def find_unresolved_args(method_node, declared_arg_nodes); end

  # @return [Boolean]
  def ignore_arguments_type?(resolve_method_node); end

  def inferred_arg_name(name_as_string); end
  def method_name(node); end
  def register_offense(node, unresolved_args); end

  # @return [Boolean]
  def scope_changing_syntax?(node); end

  # @return [Boolean]
  def scoped_node?(node); end
end

RuboCop::Cop::GraphQL::UnusedArgument::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::IgnoredPattern = RuboCop::Cop::AllowedPattern

# RuboCop GraphQL project namespace
module RuboCop::GraphQL; end

class RuboCop::GraphQL::Argument
  extend ::RuboCop::AST::NodePattern::Macros

  # @return [Argument] a new instance of Argument
  def initialize(node); end

  def argument_as(param0 = T.unsafe(nil)); end
  def argument_description(param0 = T.unsafe(nil)); end
  def argument_name(param0 = T.unsafe(nil)); end
  def as; end
  def block; end
  def description; end
  def kwargs; end
  def name; end

  # Returns the value of attribute node.
  def node; end
end

class RuboCop::GraphQL::Argument::Block
  include ::RuboCop::GraphQL::DescriptionMethod
  extend ::RuboCop::AST::NodePattern::Macros

  # @return [Block] a new instance of Block
  def initialize(argument_node); end

  def argument_block(param0 = T.unsafe(nil)); end
  def description; end
end

class RuboCop::GraphQL::Argument::Kwargs
  extend ::RuboCop::AST::NodePattern::Macros

  # @return [Kwargs] a new instance of Kwargs
  def initialize(argument_node); end

  def argument_kwargs(param0 = T.unsafe(nil)); end
  def as; end
  def as_kwarg?(param0 = T.unsafe(nil)); end
  def description; end
  def description_kwarg?(param0 = T.unsafe(nil)); end
  def loads; end
  def loads_kwarg?(param0 = T.unsafe(nil)); end
end

RuboCop::GraphQL::CONFIG = T.let(T.unsafe(nil), Hash)
RuboCop::GraphQL::CONFIG_DEFAULT = T.let(T.unsafe(nil), Pathname)

class RuboCop::GraphQL::Class
  # @return [Class] a new instance of Class
  def initialize(node); end

  # @return [Boolean]
  def nested?; end

  # Returns the value of attribute node.
  def node; end
end

# Matches a variety of description formats commonly seen in Rails applications
#
#   description 'blah'
#
#   description "blah"
#
#   description <<~EOT
#      blah
#      bloop
#   EOT
#
#   description <<-EOT.squish
#      blah
#      bloop
#   EOT
module RuboCop::GraphQL::DescriptionMethod
  extend ::RuboCop::AST::NodePattern::Macros

  def description_method_call?(param0 = T.unsafe(nil)); end
  def description_with_block_arg?(param0 = T.unsafe(nil)); end
  def find_description_method(nodes); end
end

RuboCop::GraphQL::DescriptionMethod::DESCRIPTION_STRING = T.let(T.unsafe(nil), String)
module RuboCop::GraphQL::Ext; end
module RuboCop::GraphQL::Ext::SnakeCase; end
RuboCop::GraphQL::Ext::SnakeCase::SNAKE_CASE = T.let(T.unsafe(nil), Regexp)

class RuboCop::GraphQL::Field
  extend ::Forwardable
  extend ::RuboCop::AST::NodePattern::Macros

  # @return [Field] a new instance of Field
  def initialize(node); end

  def block; end
  def description; end
  def field_description(param0 = T.unsafe(nil)); end
  def field_name(param0 = T.unsafe(nil)); end
  def field_with_body_name(param0 = T.unsafe(nil)); end
  def kwargs; end
  def name; end

  # Returns the value of attribute node.
  def node; end

  def parent(*args, **_arg1, &block); end
  def resolver_method_name; end
  def schema_member; end
  def sibling_index(*args, **_arg1, &block); end
  def underscore_name; end

  private

  def root_node; end

  # @return [Boolean]
  def root_node?(node); end

  # @return [Boolean]
  def root_with_siblings?(node); end
end

class RuboCop::GraphQL::Field::Block
  include ::RuboCop::GraphQL::DescriptionMethod
  extend ::RuboCop::AST::NodePattern::Macros

  # @return [Block] a new instance of Block
  def initialize(field_node); end

  def description; end
  def field_block(param0 = T.unsafe(nil)); end
end

RuboCop::GraphQL::Field::CONFLICT_FIELD_NAMES = T.let(T.unsafe(nil), Set)
RuboCop::GraphQL::Field::GRAPHQL_RUBY_KEYWORDS = T.let(T.unsafe(nil), Array)

class RuboCop::GraphQL::Field::Kwargs
  extend ::RuboCop::AST::NodePattern::Macros

  # @return [Kwargs] a new instance of Kwargs
  def initialize(field_node); end

  def description; end
  def description_kwarg?(param0 = T.unsafe(nil)); end
  def field_kwargs(param0 = T.unsafe(nil)); end
  def hash_key; end
  def hash_key_kwarg?(param0 = T.unsafe(nil)); end
  def method; end
  def method_kwarg?(param0 = T.unsafe(nil)); end
  def resolver; end
  def resolver_kwarg?(param0 = T.unsafe(nil)); end
  def resolver_method_name; end
  def resolver_method_option(param0 = T.unsafe(nil)); end
end

# These constants were extracted from graphql-ruby in lib/graphql/schema/member/has_fields.rb
RuboCop::GraphQL::Field::RUBY_KEYWORDS = T.let(T.unsafe(nil), Array)

module RuboCop::GraphQL::Heredoc
  # @return [Boolean]
  def heredoc?(node); end

  def range_including_heredoc(node); end
end

# Because RuboCop doesn't yet support plugins, we have to monkey patch in a
# bit of our configuration.
module RuboCop::GraphQL::Inject
  class << self
    def defaults!; end
  end
end

module RuboCop::GraphQL::NodePattern
  extend ::RuboCop::AST::NodePattern::Macros

  def argument?(param0 = T.unsafe(nil)); end

  # @return [Boolean]
  def field?(node); end

  def field_definition?(param0 = T.unsafe(nil)); end
  def field_definition_with_body?(param0 = T.unsafe(nil)); end
end

# Shared methods to check duplicated definitions
module RuboCop::GraphQL::NodeUniqueness
  def current_class_full_name(node); end
end

RuboCop::GraphQL::PROJECT_ROOT = T.let(T.unsafe(nil), Pathname)

class RuboCop::GraphQL::SchemaMember
  extend ::RuboCop::AST::NodePattern::Macros

  # @return [SchemaMember] a new instance of SchemaMember
  def initialize(node); end

  def body; end
  def class_contents(param0 = T.unsafe(nil)); end
  def find_method_definition(method_name); end

  # Returns the value of attribute node.
  def node; end
end

module RuboCop::GraphQL::Sorbet
  extend ::RuboCop::AST::NodePattern::Macros

  # @return [Boolean]
  def has_sorbet_signature?(node); end

  def sorbet_signature(param0 = T.unsafe(nil)); end
  def sorbet_signature_for(node); end

  private

  # @return [Boolean]
  def siblings_in_sequence?(first_node, second_node); end
end

module RuboCop::GraphQL::SwapRange
  include ::RuboCop::Cop::RangeHelp

  def declaration(node); end
  def swap_range(corrector, current, previous); end
end

RuboCop::GraphQL::VERSION = T.let(T.unsafe(nil), String)
RuboCop::NodePattern = RuboCop::AST::NodePattern
RuboCop::ProcessedSource = RuboCop::AST::ProcessedSource
RuboCop::Token = RuboCop::AST::Token
module UnderscoreString; end
