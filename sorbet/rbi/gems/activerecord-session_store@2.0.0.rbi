# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `activerecord-session_store` gem.
# Please instead update this file by running `bin/tapioca gem activerecord-session_store`.

module ActionDispatch
  extend ::ActiveSupport::Autoload

  def test_app; end
  def test_app=(val); end

  class << self
    def test_app; end
    def test_app=(val); end
  end
end

module ActionDispatch::Session; end

# = Active Record Session Store
#
# A session store backed by an Active Record class. A default class is
# provided, but any object duck-typing to an Active Record Session class
# with text +session_id+ and +data+ attributes is sufficient.
#
# The default assumes a +sessions+ tables with columns:
#   +id+ (numeric primary key),
#   +session_id+ (string, usually varchar; maximum length is 255), and
#   +data+ (text or longtext; careful if your session data exceeds 65KB).
#
# The +session_id+ column should always be indexed for speedy lookups.
# Session data is marshaled to the +data+ column in Base64 format.
# If the data you write is larger than the column's size limit,
# ActionController::SessionOverflowError will be raised.
#
# You may configure the table name, primary key, and data column.
# For example, at the end of <tt>config/application.rb</tt>:
#
#   ActiveRecord::SessionStore::Session.table_name = 'legacy_session_table'
#   ActiveRecord::SessionStore::Session.primary_key = 'session_id'
#   ActiveRecord::SessionStore::Session.data_column_name = 'legacy_session_data'
#
# Note that setting the primary key to the +session_id+ frees you from
# having a separate +id+ column if you don't want it. However, you must
# set <tt>session.model.id = session.session_id</tt> by hand!  A before filter
# on ApplicationController is a good place.
#
# Since the default class is a simple Active Record, you get timestamps
# for free if you add +created_at+ and +updated_at+ datetime columns to
# the +sessions+ table, making periodic session expiration a snap.
#
# You may provide your own session class implementation, whether a
# feature-packed Active Record or a bare-metal high-performance SQL
# store, by setting
#
#   ActionDispatch::Session::ActiveRecordStore.session_class = MySessionClass
#
# You must implement these methods:
#
#   self.find_by_session_id(session_id)
#   initialize(hash_of_session_id_and_data, options_hash = {})
#   attr_reader :session_id
#   attr_accessor :data
#   save
#   destroy
#
# The example SqlBypass class is a generic SQL session store. You may
# use it as a basis for high-performance database-specific stores.
class ActionDispatch::Session::ActiveRecordStore < ::ActionDispatch::Session::AbstractSecureStore
  def session_class; end
  def session_class=(val); end

  private

  def delete_session(request, session_id, options); end
  def find_session(request, id); end
  def get_session(request, sid); end
  def get_session_model(request, id); end
  def get_session_with_fallback(sid); end
  def logger; end
  def write_session(request, sid, session_data, options); end

  class << self
    # @return [Boolean]
    def private_session_id?(session_id); end

    def session_class; end
    def session_class=(val); end
  end
end

ActionDispatch::Session::ActiveRecordStore::ENV_SESSION_OPTIONS_KEY = T.let(T.unsafe(nil), String)

module ActionDispatch::Session::ActiveRecordStore::NilLogger
  class << self
    def silence; end
  end
end

ActionDispatch::Session::ActiveRecordStore::SESSION_RECORD_KEY = T.let(T.unsafe(nil), String)

module ActiveRecord
  extend ::ActiveSupport::Autoload

  class << self
    def action_on_strict_loading_violation; end
    def action_on_strict_loading_violation=(_arg0); end
    def application_record_class; end
    def application_record_class=(_arg0); end
    def async_query_executor; end
    def async_query_executor=(_arg0); end
    def default_timezone; end

    # Determines whether to use Time.utc (using :utc) or Time.local (using :local) when pulling
    # dates and times from the database. This is set to :utc by default.
    def default_timezone=(default_timezone); end

    def dump_schema_after_migration; end
    def dump_schema_after_migration=(_arg0); end
    def dump_schemas; end
    def dump_schemas=(_arg0); end
    def eager_load!; end
    def error_on_ignored_order; end
    def error_on_ignored_order=(_arg0); end

    # Returns the currently loaded version of Active Record as a <tt>Gem::Version</tt>.
    def gem_version; end

    def global_executor_concurrency; end

    # Set the +global_executor_concurrency+. This configuration value can only be used
    # with the global thread pool async query executor.
    def global_executor_concurrency=(global_executor_concurrency); end

    def global_thread_pool_async_query_executor; end
    def index_nested_attribute_errors; end
    def index_nested_attribute_errors=(_arg0); end
    def lazily_load_schema_cache; end
    def lazily_load_schema_cache=(_arg0); end
    def legacy_connection_handling; end
    def legacy_connection_handling=(_arg0); end
    def maintain_test_schema; end
    def maintain_test_schema=(_arg0); end
    def query_transformers; end
    def query_transformers=(_arg0); end
    def queues; end
    def queues=(_arg0); end
    def reading_role; end
    def reading_role=(_arg0); end
    def schema_cache_ignored_tables; end
    def schema_cache_ignored_tables=(_arg0); end
    def schema_format; end
    def schema_format=(_arg0); end
    def suppress_multiple_database_warning; end
    def suppress_multiple_database_warning=(_arg0); end
    def timestamped_migrations; end
    def timestamped_migrations=(_arg0); end
    def verbose_query_logs; end
    def verbose_query_logs=(_arg0); end
    def verify_foreign_keys_for_fixtures; end
    def verify_foreign_keys_for_fixtures=(_arg0); end

    # Returns the currently loaded version of Active Record as a <tt>Gem::Version</tt>.
    def version; end

    def warn_on_records_fetched_greater_than; end
    def warn_on_records_fetched_greater_than=(_arg0); end
    def writing_role; end
    def writing_role=(_arg0); end
  end
end

# MigrationProxy is used to defer loading of the actual migration classes
# until they are needed
class ActiveRecord::MigrationProxy < ::Struct
  # @return [MigrationProxy] a new instance of MigrationProxy
  def initialize(name, version, filename, scope); end

  def announce(*_arg0, **_arg1, &_arg2); end
  def basename; end
  def disable_ddl_transaction(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute filename
  #
  # @return [Object] the current value of filename
  def filename; end

  # Sets the attribute filename
  #
  # @param value [Object] the value to set the attribute filename to.
  # @return [Object] the newly set value
  def filename=(_); end

  def migrate(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute name
  #
  # @return [Object] the current value of name
  def name; end

  # Sets the attribute name
  #
  # @param value [Object] the value to set the attribute name to.
  # @return [Object] the newly set value
  def name=(_); end

  # Returns the value of attribute scope
  #
  # @return [Object] the current value of scope
  def scope; end

  # Sets the attribute scope
  #
  # @param value [Object] the value to set the attribute scope to.
  # @return [Object] the newly set value
  def scope=(_); end

  # Returns the value of attribute version
  #
  # @return [Object] the current value of version
  def version; end

  # Sets the attribute version
  #
  # @param value [Object] the value to set the attribute version to.
  # @return [Object] the newly set value
  def version=(_); end

  def write(*_arg0, **_arg1, &_arg2); end

  private

  def load_migration; end
  def migration; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

module ActiveRecord::SessionStore; end

module ActiveRecord::SessionStore::ClassMethods
  def create_table!; end
  def deserialize(data); end
  def drop_table!; end
  def serialize(data); end
  def serializer; end
  def serializer=(val); end
  def serializer_class; end

  class << self
    def serializer; end
    def serializer=(val); end
  end
end

# Transparently migrates existing session values from Marshal to JSON
class ActiveRecord::SessionStore::ClassMethods::HybridSerializer < ::ActiveRecord::SessionStore::ClassMethods::JsonSerializer
  class << self
    def load(value); end

    # @return [Boolean]
    def needs_migration?(value); end
  end
end

ActiveRecord::SessionStore::ClassMethods::HybridSerializer::MARSHAL_SIGNATURE = T.let(T.unsafe(nil), String)

# Uses built-in JSON library to encode/decode session
class ActiveRecord::SessionStore::ClassMethods::JsonSerializer
  class << self
    def dump(value); end
    def load(value); end
  end
end

# Use Marshal with Base64 encoding
class ActiveRecord::SessionStore::ClassMethods::MarshalSerializer
  class << self
    def dump(value); end
    def load(value); end
  end
end

# Defer serialization to the ActiveRecord database adapter
class ActiveRecord::SessionStore::ClassMethods::NullSerializer
  class << self
    def dump(value); end
    def load(value); end
  end
end

class ActiveRecord::SessionStore::Railtie < ::Rails::Railtie; end

# The default Active Record class.
class ActiveRecord::SessionStore::Session < ::ActiveRecord::Base
  include ::ActiveRecord::SessionStore::Session::GeneratedAttributeMethods
  include ::ActiveRecord::SessionStore::Session::GeneratedAssociationMethods
  extend ::ActiveRecord::SessionStore::ClassMethods

  # @return [Session] a new instance of Session
  def initialize(*_arg0); end

  # Lazy-deserialize session state.
  def data; end

  # Sets the attribute data
  #
  # @param value the value to set the attribute data to.
  def data=(_arg0); end

  # :singleton-method:
  # Customizable data column name. Defaults to 'data'.
  def data_column_name; end

  def data_column_name=(val); end

  # Has the session been loaded yet?
  #
  # @return [Boolean]
  def loaded?; end

  # This method was introduced when addressing CVE-2019-16782
  # (see https://github.com/rack/rack/security/advisories/GHSA-hrqr-hxpp-chr3).
  # Sessions created on version <= 1.1.3 were guessable via a timing attack.
  # To secure sessions created on those old versions, this method can be called
  # on all existing sessions in the database. Users will not lose their session
  # when this is done.
  def secure!; end

  private

  # Ensures that the data about to be stored in the database is not
  # larger than the data storage column. Raises
  # ActionController::SessionOverflowError.
  def raise_on_session_data_overflow!; end

  def serialize_data!; end

  class << self
    def __callbacks; end
    def _validators; end
    def data_column_name; end
    def data_column_name=(val); end
    def data_column_size_limit; end
    def defined_enums; end

    # Hook to set up sessid compatibility.
    def find_by_session_id(session_id); end

    private

    def session_id_column; end

    # Compatibility with tables using sessid instead of session_id.
    def setup_sessid_compatibility!; end
  end
end

module ActiveRecord::SessionStore::Session::GeneratedAssociationMethods; end
module ActiveRecord::SessionStore::Session::GeneratedAttributeMethods; end
ActiveRecord::SessionStore::Session::SEMAPHORE = T.let(T.unsafe(nil), Thread::Mutex)

# A barebones session store which duck-types with the default session
# store but bypasses Active Record and issues SQL directly. This is
# an example session model class meant as a basis for your own classes.
#
# The database connection, table name, and session id and data columns
# are configurable class attributes. Serializing and deserializeing
# are implemented as class methods that you may override. By default,
# serializing data is
#
#   ::Base64.encode64(Marshal.dump(data))
#
# and deserializing data is
#
#   Marshal.load(::Base64.decode64(data))
#
# This serializing behavior is intended to store the widest range of
# binary session data in a +text+ column. For higher performance,
# store in a +blob+ column instead and forgo the Base64 encoding.
class ActiveRecord::SessionStore::SqlBypass
  extend ::ActiveRecord::SessionStore::ClassMethods

  # Look for normal and serialized data, self.find_by_session_id's way of
  # telling us to postpone deserializing until the data is requested.
  # We need to handle a normal data attribute in case of a new record.
  #
  # @return [SqlBypass] a new instance of SqlBypass
  def initialize(attributes); end

  def connection(*_arg0, **_arg1, &_arg2); end
  def connection=(arg); end
  def connection_pool(*_arg0, **_arg1, &_arg2); end
  def connection_pool=(arg); end

  # Lazy-deserialize session state.
  def data; end

  # Sets the attribute data
  #
  # @param value the value to set the attribute data to.
  def data=(_arg0); end

  # :singleton-method:
  # The data field defaults to 'data'.
  def data_column; end

  def data_column=(val); end
  def destroy; end

  # @return [Boolean]
  def loaded?; end

  # Returns the value of attribute new_record.
  def new_record; end

  # Returns the value of attribute new_record.
  def new_record?; end

  # Returns true if the record is persisted, i.e. it's not a new record
  #
  # @return [Boolean]
  def persisted?; end

  def save; end

  # Returns the value of attribute session_id.
  def session_id; end

  # Sets the attribute session_id
  #
  # @param value the value to set the attribute session_id to.
  def session_id=(_arg0); end

  # :singleton-method:
  # The session id field defaults to 'session_id'.
  def session_id_column; end

  def session_id_column=(val); end

  # :singleton-method:
  # The table name defaults to 'sessions'.
  def table_name; end

  def table_name=(val); end

  class << self
    def connection; end

    # Use the ActiveRecord::Base.connection by default.
    def connection=(_arg0); end

    def connection_pool; end

    # Use the ActiveRecord::Base.connection_pool by default.
    def connection_pool=(_arg0); end

    def data_column; end
    def data_column=(val); end
    def data_column_name; end

    # Look up a session by id and deserialize its data if found.
    def find_by_session_id(session_id); end

    def session_id_column; end
    def session_id_column=(val); end
    def table_name; end
    def table_name=(val); end
  end
end

ActiveRecord::SessionStore::VERSION = T.let(T.unsafe(nil), String)

# Raised when unknown attributes are supplied via mass assignment.
ActiveRecord::UnknownAttributeError = ActiveModel::UnknownAttributeError
